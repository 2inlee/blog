<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-04-05T12:19:18+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">시를 좋아하는 프로그래머</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>AlphateamInho</name></author><entry><title type="html">인공신경망과 퍼셉트론</title><link href="http://localhost:4000/ai/2023/04/05/perceptron.html" rel="alternate" type="text/html" title="인공신경망과 퍼셉트론" /><published>2023-04-05T00:00:00+09:00</published><updated>2023-04-05T00:00:00+09:00</updated><id>http://localhost:4000/ai/2023/04/05/perceptron</id><content type="html" xml:base="http://localhost:4000/ai/2023/04/05/perceptron.html"><![CDATA[<h2 id="퍼셉트론과-신경망">퍼셉트론과 신경망</h2>
<hr />

<p>퍼셉트론은 신경망의 기본 구성요소입니다.  <br />
신경망(Neural Net)의 기본 구조를 보면 보통 아래와 같이 그립니다.</p>

<p><img src="https://user-images.githubusercontent.com/95608811/229966707-cea3fd99-1930-406b-b8a8-70a33e52b74f.png" width="800px" />
이 중 파란색으로 동그라미 친 부분, 신경망의 구성요소를 퍼셉트론이라고 합니다.</p>
<blockquote>
  <p>다른 말로는 Dense(밀집) 혹은 노드(Node) 라고도 부릅니다.</p>
</blockquote>

<h2 id="퍼셉트론의-구성요소">퍼셉트론의 구성요소</h2>
<hr />
<p>위 그림의 신경망에서 하나의 퍼셉트론을 확대해서 보면,</p>

<p><img src="https://user-images.githubusercontent.com/95608811/229966745-2b1c6bbe-0a89-4718-a437-9ce6c2d56d7c.png" width="800px" /></p>

<p>그림과 같이 퍼셉트론은 입력(inputs), 가중치(Connection Weight), 바이어스(bias), 합 연산(Sum), 활성 함수(Activation Function)로 구성되어 있습니다. <br />
오느날 인공신경망에서 이용하는 퍼셉트론은 선형 분류기로 이는 입력과 가중치들의 곱을 모두 더한 뒤 활성 함수를 적용해서 그 값이 0보다 크면 1, 0보다 작으면 -1을 출력하는 구조이다.</p>

<p><img src="https://user-images.githubusercontent.com/95608811/176060497-7cb6bb9e-1493-4ac0-8209-48fb38ade3da.png" width="800px" /></p>

<ul>
  <li>그래서 입력을 넣고 입력에 대한 결과를 출력하였을때 원하는 값이 나오도록 가중치를 조절한다.  <br />
학습이라는게 결국 그 가중치값을 가장 많은 입력에 대해 가장 근접한 가중치를 찾는 과정이라고 볼 수 있다.</li>
</ul>

<h2 id="신경망으로-풀-수-있는-문제들">신경망으로 풀 수 있는 문제들</h2>
<hr />
<p>활성화 함수, 네트워크 구조 변경을 통해 문제를 풀 수 있습니다. <br />
대표적인 문제로는 분류(Classification)와 회귀(Regression)로 나눌 수 있습니다.</p>

<h3 id="분류classification">분류(Classification)</h3>
<p>실생활에서 AI가 적용되는 많은 분야는 분류문제를 해결한 것이 많습니다. <br />
그 예로는 개와 고양이를 분류하는 문제 또는 물체를 Detection 하였을 때, 어떤 물체인 지 분류하는 문제 등  <br />
실생활에서 많은 부분에 사용되고 있습니다.</p>

<p><img src="https://user-images.githubusercontent.com/95608811/229966775-a3bc8443-2914-4fab-87a6-bc04c0f34589.png" width="800px" /></p>

<p>위 사진과 같이 분류해야 하는 class의 갯수 만큼 Output layer의 퍼셉트론 개수가 정해지게 된다.</p>

<h3 id="회귀regression">회귀(Regression)</h3>
<p>분류를 제외한 다른 문제는 회귀(Regression)문제에 해당합니다.  <br />
공부한 시간(x)을 가지고 합격확률(y)를 예측하거나, 키(x)를 가지고 몸무게(y)를 예측하는 등 분류하는 것이 아니라 확률 또는 값과 같은 숫자를 맞추는 문제라고 생각하면 됩니다.</p>

<p><img src="https://user-images.githubusercontent.com/95608811/229966792-2ed7e419-001b-47a1-8ace-602987da7dbc.png" width="800px" /></p>

<p>위와 같은 간단한 예시에서는 보통 Output layer의 퍼셉트론 개수를 하나로 두는 경우가 많습니다.  <br />
이런 문제에 대해서 마지막 퍼셉트론의 활성화 함수를 정할 때, 활성함수를 문제에 맞게끔 설정해야 합니다. <br />
0~1 사이의 확률을 가리키는 문제에서는 시그모이어함수, 다채로운 값을 가질 수 있을땐 ReLU 등  <br />
활성함수에 대해서는 다음 포스팅에서 다루겠습니다.</p>]]></content><author><name>Ino</name></author><category term="ai" /><category term="ai" /><summary type="html"><![CDATA[퍼셉트론과 신경망]]></summary></entry><entry><title type="html">SOLID - 객체 지향 설계의 5가지 원칙</title><link href="http://localhost:4000/spring,/java/2022/10/10/SOLID.html" rel="alternate" type="text/html" title="SOLID - 객체 지향 설계의 5가지 원칙" /><published>2022-10-10T00:00:00+09:00</published><updated>2022-10-10T00:00:00+09:00</updated><id>http://localhost:4000/spring,/java/2022/10/10/SOLID</id><content type="html" xml:base="http://localhost:4000/spring,/java/2022/10/10/SOLID.html"><![CDATA[<h1 id="solid">SOLID</h1>
<h3 id="클린코드로-유명한-로버트-마틴의-객체-지향-설계의-5가지-원칙">클린코드로 유명한 로버트 마틴의 객체 지향 설계의 5가지 원칙</h3>

<p>SOLID란 객체 지향 프로그래밍을 하면서 지켜야하는 5대 원칙으로 각각 SRP(단일 책임 원칙), OCP(개방-폐쇄 원칙), LSP(리스코프 치환 원칙), DIP(의존 역전 원칙), ISP(인터페이스 분리 원칙)의 앞글자를 따서 만들어졌다. SOLID 원칙을 철저히 지키면 시간이 지나도 변경이 용이하고, 유지보수와 확장이 쉬운 소프트웨어를 개발하는데 도움이 되는 것으로 알려져있다.</p>

<h3 id="srp--단일-책임-원칙-single-responsibility-principle">SRP : 단일 책임 원칙 (single responsibility principle)</h3>

<ul>
  <li>한 클래스는 하나의 책임만 가져야 한다.</li>
  <li>하나의 책임이라는 것은 모호하다 (문맥과 상황에 따라 다르다.)</li>
  <li>중요한 기준은 변경이다. 변경이 있을 때 파급효과가 적으면 단일 책임 원칙을 잘 따른 것
    <blockquote>
      <p>ex) 객체 생성과 사용을 분리, 디스플레이에 띄우는 부분과 핵심로직은 분리</p>
    </blockquote>
  </li>
</ul>

<h3 id="ocp--개방-폐쇄-원칙-openclosed-principle">OCP : 개방-폐쇄 원칙 (Open/Closed principle)</h3>

<ul>
  <li>소프트웨어 요소는 확장에는 열려있으나, 변경에는 닫혀있어야한다.</li>
  <li>확장에 대해 열려 있다: 요구사항이 변경될 때 새로운 동작을 추가하여 애플리케이션의 기능을 확장할 수 있다.</li>
  <li>
    <p>수정에 대해 닫혀 있다: 기존의 코드를 수정하지 않고 애플리케이션의 동작을 추가하거나 변경할 수 있다.</p>
  </li>
  <li>
    <p>개방 폐쇄 원칙을 지키기 위해서는 추상화에 의존해야 한다. 추상화란 핵심적인 부분만 남기고, 불필요한 부분은 제거함으로써 복잡한 것을 간단히 하는 것이고, 추상화를 통해 변하지 않는 부분만 남김으로써 기능을 구체화하고 확장할 수 있다. 변하지 않는 부분은 고정하고 변하는 부분을 생략하여 추상화함으로써 변경이 필요한 경우에 생략된 부분을 수정하여 개방-폐쇄의 원칙을 지킬 수 있다.</p>
  </li>
  <li>다형성을 위한 추상화를 활용해서 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현한다.</li>
</ul>

<h3 id="lsp--리스코프-치환-원칙-liskov-substitution-principle">LSP : 리스코프 치환 원칙 (Liskov substitution principle)</h3>
<ul>
  <li>프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인터페이스로 바꿀 수 있어야 한다.</li>
  <li>다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체를 믿고 사용하려면, 이 원칙이 필요하다.</li>
  <li>단순히 컴파일에 성공하는 것을 넘어서는 이야기로 상식적으로 해당 객체의 생성 목적대로 사용하면 된다.</li>
</ul>

<h3 id="isp--인터페이스-분리-원칙-interface-segregation-principle">ISP : 인터페이스 분리 원칙 (Interface segregation principle)</h3>
<ul>
  <li>특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.</li>
  <li>자동차 인터페이스 -&gt; 운전 인터페이스, 정비 인터페이스로 분리</li>
  <li>사용자 클라이언트 -&gt; 운전자 클라이언트, 정비사 클라이언트로 분리</li>
  <li>분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음</li>
  <li>인터페이스가 명확해지고, 대체 가능성이 높아진다.</li>
</ul>

<h3 id="dip--의존관계-역전-원칙-dependency-inversion-principle">DIP : 의존관계 역전 원칙 (Dependency inversion principle)</h3>
<ul>
  <li>프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.” 의존성 주입은 이 원칙을 따르는 방법 중 하나이다.</li>
  <li>쉽게 말해서 구현 클래스에 의존하지말고, 인터페이스에 의존하라는 뜻이다.</li>
  <li>앞에서 이야기한 역할(Role)에 의존하게 해야 한다는 것과 같다.  <br />
객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다.  <br />
구현체에 의존하게 되면 수정이 어려워지게 된다.</li>
</ul>

<h2 id="정리하자면">정리하자면,</h2>
<p>객체지향의 핵심은 다형성인데, 다형성 만으로는 OCP랑 DIP를 지킬 수가 없다.</p>

<p>끝.</p>

<h2 id="이-아니라-스프링은-didependency-injection으로-다형성--ocp-dip를-가능하게-지원한다">이 아니라 스프링은 DI(Dependency Injection)으로 다형성 + OCP, DIP를 가능하게 지원한다.</h2>

<p>그래서, 스프링을 쓰자.</p>]]></content><author><name>Ino</name></author><category term="spring," /><category term="java" /><category term="java" /><category term="spring" /><summary type="html"><![CDATA[SOLID 클린코드로 유명한 로버트 마틴의 객체 지향 설계의 5가지 원칙]]></summary></entry><entry><title type="html">JAVA Spring 시작하기</title><link href="http://localhost:4000/spring/2022/09/20/sprig%EC%8B%9C%EC%9E%91.html" rel="alternate" type="text/html" title="JAVA Spring 시작하기" /><published>2022-09-20T00:00:00+09:00</published><updated>2022-09-20T00:00:00+09:00</updated><id>http://localhost:4000/spring/2022/09/20/sprig%EC%8B%9C%EC%9E%91</id><content type="html" xml:base="http://localhost:4000/spring/2022/09/20/sprig%EC%8B%9C%EC%9E%91.html"><![CDATA[<h2 id="spring-라이브러리">Spring 라이브러리</h2>

<h3 id="spring-boot-library">Spring Boot Library</h3>
<ul>
  <li>spring-boot-starter-web</li>
  <li>
    <ul>
      <li>spring-boot-starter-tomcat : 톰캣(웹서버)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>spring-webmvc : 스프링 웹 MVC</li>
    </ul>
  </li>
  <li>spring-boot-starter-thymeleaf : 타입리프 템플릿 엔진(View)</li>
  <li>spring-boot-starter(공통) : 스프링부트 + 스프링코어 + 로깅</li>
  <li>
    <ul>
      <li>spring-boot</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>
        <ul>
          <li>spring-core</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <ul>
      <li>spring-boot-starter-logging</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>
        <ul>
          <li>logback, slf4j</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="test-library">Test Library</h3>
<ul>
  <li>junit : 테스트 프레임워크</li>
  <li>mockito : 목라이브러리</li>
  <li>assertj : 테스트코드를 좀 더 편하게 작성하게 도와주는 라이브러리</li>
  <li>spring-test : 스프링 통합 테스트 지원</li>
</ul>

<h2 id="controller">Controller</h2>

<p><code class="language-plaintext highlighter-rouge">src/main/java/packageName/HelloController.java</code> 에서 아래처럼 코딩후</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloController</span> <span class="o">{</span>
    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"hello"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">hello</span><span class="o">(</span><span class="nc">Model</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"data"</span><span class="o">,</span><span class="s">"hello!!"</span><span class="o">);</span>
        <span class="k">return</span> <span class="s">"hello"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">resources/templates</code> 에서 <code class="language-plaintext highlighter-rouge">hello.html</code> 을 만든후</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">xmlns:th=</span><span class="s">"http://www.thymeleaf.org"</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"UTF-8"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"X-UA-Compatible"</span> <span class="na">content=</span><span class="s">"IE=edge"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">name=</span><span class="s">"viewport"</span> <span class="na">content=</span><span class="s">"width=device-width, initial-scale=1.0"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;title&gt;</span>Document<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
<span class="nt">&lt;p</span> <span class="na">th:text=</span><span class="s">"'안녕하세요.'  + ${data}"</span><span class="nt">&gt;</span>안녕하세요 고객님 <span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>
<p>위와같이 입력하면, <code class="language-plaintext highlighter-rouge">${data}</code> 위치에 <code class="language-plaintext highlighter-rouge">hello!!</code> 가 치환되어서 들어가게된다. <br />
이는,   <br />
<code class="language-plaintext highlighter-rouge">thymeleaf</code> 템플릿엔진에서 WebBrower 가 local:8080/hello 를 spring boot 에 있는 내장 Tomcat server에 보내고 Tomcat server가  스프링컨테이너에서 hello Controller의 return이 문자(hello) 로 반환되어 있어 View Resolver가 화면을 찾아서 처리해준 결과이다. <br />
나는 <code class="language-plaintext highlighter-rouge">thymeleaf</code> 템플릿엔진이 addAttribute 의 첫번재 인자를 두번째 인자로 데이터바인딩 해주었다고 이해하고 넘어갔다.</p>

<h2 id="빌드하고-실행하기">빌드하고 실행하기</h2>
<p>쉘에서 해당 폴더에 들어간 후 <code class="language-plaintext highlighter-rouge">./gradlew build </code> 를 통해 바로 실행시켜준다.  <br />
그럼 <code class="language-plaintext highlighter-rouge">build</code> 디렉토리가 생긴다. <br />
<code class="language-plaintext highlighter-rouge">build</code>디렉토리에 있는 <code class="language-plaintext highlighter-rouge">libs</code>에 들어가서 <code class="language-plaintext highlighter-rouge">java -jar hello-0.0.1-SNAPSHOT.jar</code> 로 .jar 파일을 바로 실행할 수 있다.
<code class="language-plaintext highlighter-rouge">.jar</code> 파일을 실행하면 Eclipse 또는 intellij 내에서 Run을 시키지 않아도 바로 서버를 구동시킬 수 있다.</p>]]></content><author><name>Ino</name></author><category term="spring" /><category term="java" /><category term="spring" /><summary type="html"><![CDATA[Spring 라이브러리]]></summary></entry><entry><title type="html">C언어 Makefile 이해하기</title><link href="http://localhost:4000/c/2022/09/19/Makefile.html" rel="alternate" type="text/html" title="C언어 Makefile 이해하기" /><published>2022-09-19T00:00:00+09:00</published><updated>2022-09-19T00:00:00+09:00</updated><id>http://localhost:4000/c/2022/09/19/Makefile</id><content type="html" xml:base="http://localhost:4000/c/2022/09/19/Makefile.html"><![CDATA[<h2 id="makefile-왜-쓰는데">Makefile 왜 쓰는데?</h2>
<p>간단한 소스코드 파일 한두개라면 몰라도 컴파일 해야할 코드 갯수가 굉장히 많아지면 gcc 방식으로 하나하나 컴파일 하는것은 시간도 오래걸리고 굉장히 귀찮은 일이된다.  <br />
그래서 반복적인 작업을 피하기 위해서 쓰는것이 make 유틸리티이다.</p>

<h2 id="make--makefile">make / Makefile</h2>
<p>make는 유틸리티 이름이다. <br />
make 유틸리티는 Makefile이라는 파일의 내용을 읽어서 목표 파일(target)을 만듭니다.</p>

<h2 id="컴파일과정">컴파일과정</h2>
<ol>
  <li>c파일에서 object 파일 생성하기 <br />
ex) <code class="language-plaintext highlighter-rouge">gcc -c -o ft_strlen.o ft_strlen.c</code>
    <ul>
      <li>-c 옵션은 해당 c파일을 .o(오브젝트)파일로 만들어준다.</li>
      <li>-o 옵션은 생성될 파일의 이름을 지정해준다.
        <blockquote>
          <p>지금처럼 -c 옵션을 쓸 때는 -o 옵션으로 output name을 지정해주지 않아도 자동으로 .c의 이름의 .o 파일로
만들어진다.
하지만  실행 파일 생성시 -o 옵션을 넣지 않으면 모든 파일이 a.out 이라는 이름을 가지게 되므로 여러 개의 실행 파일을 생성해야 할 때 -o 옵션을 넣어서 이름을 명시적으로 붙여주는 것이 좋다.</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>
    <p>각 object파일을 link해서 컴파일을 통해 exe 실행파일 생성하기 <br />
<code class="language-plaintext highlighter-rouge">gcc -o strlen.exe main.o ft_strlen.o</code>  <br />
Object 파일의 순서들은 상관이 없고 해당 내용처럼 써주면 main.o 와 ft_strlen을 링크해서 strlen.exe 를 생성한다.</p>
  </li>
  <li>실행하기 <br />
<code class="language-plaintext highlighter-rouge">./strlen.exe</code> 이런식으로 실행을 하면 해당 파일이 실행된다. <br />
추가로, main 에 argc, argv[] 인자를 실행시 넣고 싶으면, <code class="language-plaintext highlighter-rouge">./strlen.exe [argv[0]][argv[1]]</code>
```c
// 2022.09.20 편집중//</li>
</ol>]]></content><author><name>Ino</name></author><category term="c" /><category term="c" /><summary type="html"><![CDATA[Makefile 왜 쓰는데? 간단한 소스코드 파일 한두개라면 몰라도 컴파일 해야할 코드 갯수가 굉장히 많아지면 gcc 방식으로 하나하나 컴파일 하는것은 시간도 오래걸리고 굉장히 귀찮은 일이된다. 그래서 반복적인 작업을 피하기 위해서 쓰는것이 make 유틸리티이다.]]></summary></entry><entry><title type="html">C언어 write 함수</title><link href="http://localhost:4000/c/2022/09/18/%ED%99%98%EA%B2%BD%EB%B3%80%EC%88%98%EC%99%80-id.html" rel="alternate" type="text/html" title="C언어 write 함수" /><published>2022-09-18T00:00:00+09:00</published><updated>2022-09-18T00:00:00+09:00</updated><id>http://localhost:4000/c/2022/09/18/%ED%99%98%EA%B2%BD%EB%B3%80%EC%88%98%EC%99%80%20id</id><content type="html" xml:base="http://localhost:4000/c/2022/09/18/%ED%99%98%EA%B2%BD%EB%B3%80%EC%88%98%EC%99%80-id.html"><![CDATA[<h2 id="unistdh-가-뭔데">unistd.h 가 뭔데?</h2>
<p>POSIX 운영체제 API에 대한 엑세스를 제공하는 헤더파일이다.   <br />
보통 Unix 에 쓰이는 표준 심볼들과 상수들을 정의해 놓은 것이기 때문에 unistd.h에 포함되어 있는 내용은 대부분 유닉스환경에서만 쓸 수 있다.</p>

<h2 id="write-함수를-어디에-쓰는건데">write 함수를 어디에 쓰는건데?</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="kt">ssize_t</span> <span class="nf">write</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">);</span>
</code></pre></div></div>

<p>보통 오픈한 파일에 데이터를 쓸 때 사용하는 함수이다.  <br />
return value : 성공 시 기록된 바이트수, 에러시 -1을 return 한다.</p>

<p>그런데,해당 함수를 <stdio.h> 에 있는 printf() 대용으로 사용하는 경우도 있는데 이런경우 어떤식으로 사용하는지에 대해 간단하게 설명하고자 한다.</stdio.h></p>

<p>일단 함수를 사용하면 파라미터에 어떤 value를 넣는지에 대해 알아야한다.</p>
<ul>
  <li>해당 포스트는 write함수를 모니터에 버퍼출력용으로 사용하는 방법에 대해 알아보는 것이기 때문에,
일반적으올 사용하는 방법 및 개념과는 많이 다를 수 있음</li>
</ul>

<h2 id="첫번째-파라미터-파일디스크립터">첫번째 파라미터 파일디스크립터</h2>
<p>파일 디스크립터(File Descriptor)란 리눅스 혹은 유닉스 계열의 시스템에서 프로세스(process)가 파일(file)을 다룰 때 사용하는 개념으로, 프로세스에서 특정 파일에 접근할 때 사용하는 추상적인 값이다. 파일 디스크럽터는 일반적으로 0이 아닌 정수값을 갖는다.</p>

<p>흔히 유닉스 시스템에서 모든 것을 파일이라고 한다. <br />
유닉스 시스템에서 프로세스가 이 파일들을 접근할 때 파일 디스크립터라는 개념을 이용한다. 프로세스가 열려있는 파일에 시스템 콜을 이용해서 접근할 때, 파일 디스크립터(FD)값을 이용해서 파일을 지칭할 수 있다.</p>

<p>프로그램이 프로세스로 메모리에서 실행될 때, 기본적으로 할당되는 파일디스크립터는 표준입력(Standard Input), 표준 출력(Standard Output), 표준에러(Standard Error)이며 이들에게 각각 0, 1, 2라는 정수가 할당된다.</p>

<p>즉, 첫번째 파라미터인 int fd에는 0,1,2의 값이 들어갈 수 있다.</p>

<p>그 중에 우리는 표준출력만을 사용하므로 printf 대용으로 일반적인 값을 출력할 떈 1 로 고정해서 써도 무방하다.</p>

<h2 id="두번째-파라미터-버퍼">두번째 파라미터 버퍼</h2>
<p>출력할 내용을 적으면 된다.
유의해야할 점은 버퍼가 char 형태로 받아지기 때문에 int형을 write 하고싶다면, itoa 등의 함수를 사용하거나 아스키값을 char 형태만큼 적당히(?) 조절해서 써줘야한다.</p>

<h2 id="세번째-파라미터-nbytes">세번째 파라미터 nbytes</h2>
<p>그냥 출력해야 할 버퍼가 몇 바이트인지 맞춰서 쓰면 된다.</p>

<h2 id="종합하자면">종합하자면,</h2>
<h3 id="buf로부터-filedes로-nbytes만큼의-데이터를-쓴다">buf로부터 filedes로 nbytes만큼의 데이터를 쓴다.</h3>

<p>Hello World 를 출력하고싶다면,</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"Hello World"</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>

<span class="kt">char</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
<span class="n">a</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Hello World"</span><span class="p">;</span>
<span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
</code></pre></div></div>

<p>이런식으로 출력을 원하는 리터럴문자를 직접 큰따옴표로 묶어서 넣어주거나, 변수의 주소값을 넣어주면 출력가능하다.</p>

<p>int 형태는 char 형태로 출력가능하다고 했었는데,</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"0123456789"</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</code></pre></div></div>
<p>이런식의 출력은 결국 숫자가 들어간 문자열이기 때문에 출력가능하다.</p>]]></content><author><name>Ino</name></author><category term="c" /><category term="c" /><summary type="html"><![CDATA[unistd.h 가 뭔데? POSIX 운영체제 API에 대한 엑세스를 제공하는 헤더파일이다. 보통 Unix 에 쓰이는 표준 심볼들과 상수들을 정의해 놓은 것이기 때문에 unistd.h에 포함되어 있는 내용은 대부분 유닉스환경에서만 쓸 수 있다.]]></summary></entry><entry><title type="html">C언어 포인터와 동적메모리</title><link href="http://localhost:4000/c/2022/08/12/c%EC%96%B8%EC%96%B4%ED%8F%AC%EC%9D%B8%ED%84%B0.html" rel="alternate" type="text/html" title="C언어 포인터와 동적메모리" /><published>2022-08-12T00:00:00+09:00</published><updated>2022-08-12T00:00:00+09:00</updated><id>http://localhost:4000/c/2022/08/12/c%EC%96%B8%EC%96%B4%ED%8F%AC%EC%9D%B8%ED%84%B0</id><content type="html" xml:base="http://localhost:4000/c/2022/08/12/c%EC%96%B8%EC%96%B4%ED%8F%AC%EC%9D%B8%ED%84%B0.html"><![CDATA[<h2 id="메모리-영역">메모리 영역</h2>

<ol>
  <li>
    <p>코드 영역  <br />
코드 영역은 이름 처럼 작성한 코드를 저장하는 영역입니다.​</p>
  </li>
  <li>
    <p>데이터 영역  <br />
데이터 영역은 전역 변수와 정적 변수를 저장하는 영역입니다.  <br />
전역 변수는 프로그램이 시작되면서 초기화됩니다. <br />
그러므로 데이터 영역은 프로그램 시작시에 이미 메모리가 확보되어 크기가 변하지 않음을 알 수 있습니다.</p>
  </li>
  <li>
    <p>힙 영역
힙영역은 동적 메모리를 할당하는 영역입니다. <br />
C언어로 코드를 작성할 때 직접 메모리를 할당할 때가 있습니다.  <br />
이 때 메모리를 할당하는 영역이 바로 힙 영역입니다.  <br />
힙에 저장된 메모리는 함수호출이 종료되어도 사라지지 않기 때문에, 개발자가 free()함수를 통해 명시적으로 해제하거나 프로그램이 종료되어야 사라진다.   <br />
프로그램은 메모리 주소에 따라 힙 데이터에 접근한다.   <br />
힙 공간은 스택영역과 달리 크기에 제약이 없기때문에 메모리만 충분하다면 필요한만큼 확장할 수 있다.</p>
  </li>
  <li>
    <p>스택 영역  <br />
스택 영역은 지역 변수와 매개변수를 저장하는 영역입니다. <br />
지역 변수와 매개 변수 특성 상 해당 함수의 호출과 실행이 완료되면 사라집니다.  <br />
그러므로 데이터가 저장되었다가 지워지기를 반복하는 영역임을 알 수 있습니다. <br />
(자료구조에서의 스택을 알고 있으면 이해하기 편할 것이다.)</p>
  </li>
</ol>

<hr />

<h2 id="메모리할당-함수-malloccallocrealloc">메모리할당 함수 (malloc,calloc,realloc)</h2>
<blockquote>
  <p>메모리 관련함수는 헤더파일 <code class="language-plaintext highlighter-rouge">&lt;stdlib.h&gt;</code> 또는 <code class="language-plaintext highlighter-rouge">&lt;malloc.h&gt;</code>에 있다.   <br />
실제값 : *(p + i) == p[i];    <br />
주소 : p + i == &amp;p[i];</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">malloc</code> : 동적 메모리 함수</p>
<ul>
  <li>메모리를 미리 일정량 만큼 잡아두지 않고, 필요할때마다 동적으로 할당한다.</li>
  <li>필요할 때마다 동적으로 할당해서 메모리낭비를 줄여준다.</li>
  <li>형식 : 포인터변수 = (포인터변수의 데이터형 *)malloc(포인터변수의 데이터형 크기 * 필요한크기);</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
  <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// int형은 4바이트니깐, 총 40바이트를 할당한 상태이다.</span>
  <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>크기는 바이트형이고, malloc을 이용해 필요한만큼 동적할당을 해준다.</li>
  <li>사용후 free() 함수를 통해 할당된 공간을 반납해준다.</li>
</ul>

<hr />

<p><code class="language-plaintext highlighter-rouge">calloc</code> 함수</p>
<ul>
  <li>요청한 메모리공간을 0으로 초기화하여 할당함.</li>
  <li>형식 : 포인터변수 = (포인터변수의 데이터형 *)calloc(포인터변수의 데이터형 크기 * 필요한크기);</li>
  <li>malloc함수로 공간을 할당하면, 가비지값(쓰레기값)들이 들어가는데, calloc()함수를 이용해 할당하면,  <br />
원하는만큼 공간을 할당후 메모리공간도 0으로 초기화 해준다.</li>
</ul>

<hr />

<p><code class="language-plaintext highlighter-rouge">realloc</code> 함수</p>
<ul>
  <li>새로 동적메모리를 할당받고, 이전에 할당받은 메모리값을 복사하는 함수</li>
  <li>단독으로 사용이 불가능하며 이전에 malloc또는 calloc으로 할당받았던 경험이 있어야함.</li>
  <li>형식 : 포인터변수 = (포인터변수 *)realloc(기본포인터, 포인터변수의 데이터형 크기 * 필요한크기);</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
  <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
  <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">realloc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">))</span> <span class="c1">// 이전라인에서의 p의값을 복사해서 넣는다.</span>
  <span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<hr />
<h2 id="메모리문제">메모리문제</h2>
<h3 id="메모리-릭memory-leak">메모리 릭(Memory Leak)</h3>

<p>메모리 릭은 프로그램이 불필요한 메모리를 계속 점유하는 현상이다.  <br />
malloc() 또는 calloc() 등으로 동적메모리를 힙에 할당해놓고, free()를 통해 명시적으로 메모리를 해제 하지 않으면 프로그램이 작동하는동안 지속적으로 불필요한 메모리를 점유하게 된다.</p>
<blockquote>
  <p>나중에 언급하겠지만, 이러한 이유로 동적할당과 할당해제는 같은 코드블럭내에 위치하는 것이 유리하다.</p>
</blockquote>

<h3 id="댕글링-포인터dangling-pointer">댕글링 포인터(Dangling Pointer)</h3>

<p>댕글링 포인터(또는 허상 포인터)는 이미 해제된 메모리를 가르키는 포인터를 뜻한다.  <br />
동적할당된 곳을 포인터가 가리키고 있는 상태에서 해당 동적할당을 해제하게 되면, 해당 공간을 가리키고 있던 포인터에 있는 주소 공간은 아무런 의미가 없게된다.  <br />
이 때 포인터에 저장된 주소공간에서 데이터를 가져오거나 어떤 동작을 수행하면 문제가 될 수 있다.</p>
<blockquote>
  <p>차라리 아무것도 가져오지 않으면 괜찮은데, 가비지값을 가져오면서 정상동작 하는것 처럼 보이다가 예상치 못한 오류가 뜰 수도 있다.</p>
</blockquote>

<h3 id="버퍼-오버플로우-buffer-overflow">버퍼 오버플로우 (Buffer Overflow)</h3>
<p>버퍼 오버플로우는 배열 혹은 동적으로 할당된 메모리 영역을 벗어나서 쓰기 작업을 수행하는 것이다.</p>

<h3 id="널포인터-익셉션null-pointer-exception">널포인터 익셉션(Null Pointer Exception)</h3>
<p>Null로 초기화한 메모리 영역에 접근하면 발생하는 에러이다.</p>

<hr />

<h3 id="메모리-릭을-줄이는-방법">메모리 릭을 줄이는 방법</h3>

<h5 id="malloc과-free를-한-블록에서-하기">malloc과 free를 한 블록에서 하기</h5>
<p>메모리 할당과 해제는 한블록 내에서 한번씩만 한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="n">Example</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">init_example</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">Example</span> <span class="o">*</span><span class="n">example</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">example</span><span class="p">));</span> <span class="c1">// 메모리 할당</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">example</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>
    <span class="n">example</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">example</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">example</span><span class="o">-&gt;</span><span class="n">c</span> <span class="o">=</span> <span class="sc">'c'</span><span class="p">;</span>
    <span class="n">free</span><span class="p">(</span><span class="n">example</span><span class="p">);</span> <span class="c1">// 해제</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">init_example</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>
<blockquote>
  <p>출처 : 커널패닉</p>
</blockquote>

<p>위코드에서 init_example 코드블럭 내에 malloc 동적할당과 free 메모리해제를 같은 블럭내에서 한번씩 해줬기 때문에 위코드에서는 메모리릭이 발생하지 않는다.</p>]]></content><author><name>Ino</name></author><category term="c" /><category term="C" /><category term="동적할당" /><category term="메모리" /><summary type="html"><![CDATA[메모리 영역]]></summary></entry><entry><title type="html">정다면체 for Python</title><link href="http://localhost:4000/algorithm/2022/08/07/%EC%A0%95%EB%8B%A4%EB%A9%B4%EC%B2%B4.html" rel="alternate" type="text/html" title="정다면체 for Python" /><published>2022-08-07T00:00:00+09:00</published><updated>2022-08-07T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/08/07/%EC%A0%95%EB%8B%A4%EB%A9%B4%EC%B2%B4</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/08/07/%EC%A0%95%EB%8B%A4%EB%A9%B4%EC%B2%B4.html"><![CDATA[<blockquote>
  <p>문제는 너무 자세하게 기술하지 않음
출처 : 인프런 - 파이썬 알고리즘 문제풀이 (코딩테스트 대비) by 김태원 강사님</p>
</blockquote>

<h2 id="문제">문제</h2>
<p>두 개의 정 N면체와 정 M면체의 두 개의 주사위를 던져서 나올 수 있는 눈의 합 중 가장 확 률이 높은 숫자를 출력하는 프로그램을 작성하세요.
정답이 여러 개일 경우 오름차순으로 출력합니다.</p>

<h4 id="입력">입력</h4>
<p>첫 번째 줄에는 자연수 N과 M이 주어집니다. N과 M은 4, 6, 8, 12, 20 중의 하나입니다.</p>

<h4 id="출력">출력</h4>
<p>첫 번째 줄에 답을 출력합니다.</p>

<pre><code class="language-Python">n ,m= map(int,input('n과 m을 입력하시오').split())
cnt=[0]*(n+m+3)
max=0
for i in range(1, n+1):
  for j in range(1, m+1):
    cnt[i+j]=cnt[i+j]+1

for i in range(n+m+1):
  if cnt[i]&gt;max:
    max=cnt[i]

for i in range(n+m+1):
  if cnt[i]==max:
    print(i, end=' ')

</code></pre>

<h4 id="설명">설명</h4>
<p>n+m+3 의 갯수만큼 cnt의 리스트를 만들어서 0으로 초기화 시켜준다.</p>]]></content><author><name>Ino</name></author><category term="algorithm" /><category term="Python" /><category term="algorithm" /><summary type="html"><![CDATA[문제는 너무 자세하게 기술하지 않음 출처 : 인프런 - 파이썬 알고리즘 문제풀이 (코딩테스트 대비) by 김태원 강사님]]></summary></entry><entry><title type="html">자릿수의합 for Python</title><link href="http://localhost:4000/algorithm/2022/08/07/%EC%9E%90%EB%A6%BF%EC%88%98%EC%9D%98%ED%95%A9.html" rel="alternate" type="text/html" title="자릿수의합 for Python" /><published>2022-08-07T00:00:00+09:00</published><updated>2022-08-07T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/08/07/%EC%9E%90%EB%A6%BF%EC%88%98%EC%9D%98%ED%95%A9</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/08/07/%EC%9E%90%EB%A6%BF%EC%88%98%EC%9D%98%ED%95%A9.html"><![CDATA[<blockquote>
  <p>문제는 너무 자세하게 기술하지 않음
출처 : 인프런 - 파이썬 알고리즘 문제풀이 (코딩테스트 대비) by 김태원 강사님</p>
</blockquote>

<h2 id="문제">문제</h2>
<p>N개의 자연수가 입력되면 각 자연수의 자릿수의 합을 구하고, 그 합이 최대인 자연수를 출력 하는 프로그램을 작성하세요. 각 자연수의 자릿수의 합을 구하는 함수를 def digit_sum(x)를 꼭 작성해서 프로그래밍 하세요.</p>

<h4 id="입력">입력</h4>
<p>첫 줄에 자연수의 개수 N(3&lt;=N&lt;=100)이 주어지고, 그 다음 줄에 N개의 자연수가 주어진다. 각 자연수의 크기는 10,000,000를 넘지 않는다.</p>

<h4 id="출력">출력</h4>
<p>자릿수의 합이 최대인 자연수를 출력한다. 자릿수의 합이 같을 경우 입력순으로 먼저인 숫자 를 출력합니다.</p>

<pre><code class="language-Python">n = int(input('n을 입력하시오 : '))
a = list(map(int,input('n개 만큼 입력').split()))
max = -2147000000

def digit_sum(x):
  sum = 0
  while(x&gt;0):
    sum += x % 10
    x = x//10
  return sum


for x in a:
  total = digit_sum(x)
  if total &gt; max:
    max = total
    res = x

print(res)

</code></pre>]]></content><author><name>Ino</name></author><category term="algorithm" /><category term="Python" /><category term="algorithm" /><summary type="html"><![CDATA[문제는 너무 자세하게 기술하지 않음 출처 : 인프런 - 파이썬 알고리즘 문제풀이 (코딩테스트 대비) by 김태원 강사님]]></summary></entry><entry><title type="html">k번째 큰 수 for Python</title><link href="http://localhost:4000/algorithm/2022/08/07/k%EB%B2%88%EC%A7%B8%ED%81%B0%EC%88%98.html" rel="alternate" type="text/html" title="k번째 큰 수 for Python" /><published>2022-08-07T00:00:00+09:00</published><updated>2022-08-07T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/08/07/k%EB%B2%88%EC%A7%B8%ED%81%B0%EC%88%98</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/08/07/k%EB%B2%88%EC%A7%B8%ED%81%B0%EC%88%98.html"><![CDATA[<blockquote>
  <p>문제는 너무 자세하게 기술하지 않음
출처 : 인프런 - 파이썬 알고리즘 문제풀이 (코딩테스트 대비) by 김태원 강사님</p>
</blockquote>

<h2 id="문제">문제</h2>
<p>현수는 1부터 100사이의 자연수가 적힌 N장의 카드를 가지고 있습니다. 같은 숫자의 카드가 여러장 있을 수 있습니다. 현수는 이 중 3장을 뽑아 각 카드에 적힌 수를 합한 값을 기록하려 고 합니다. 3장을 뽑을 수 있는 모든 경우를 기록합니다. 기록한 값 중 K번째로 큰 수를 출력 하는 프로그램을 작성하세요.
만약 큰 수부터 만들어진 수가 25 25 23 23 22 20 19……이고 K값이 3이라면 K번째 큰 값 은 22입니다.</p>

<h4 id="입력">입력</h4>
<p>첫 줄에 자연수 N(3&lt;=N&lt;=100)과 K(1&lt;=K&lt;=50) 입력되고, 그 다음 줄에 N개의 카드값이 입력 된다.</p>

<h4 id="출력">출력</h4>
<p>첫 줄에 K번째 수를 출력합니다. K번째 수는 반드시 존재합니다.</p>

<pre><code class="language-Python">n,k = map(int,input('n과 k를 입력하시오').split())
a = list(map(int, input().split()))
res = set() # 중복을 제거하는 set() 자료구조 list자료구조에서 중복을 제거하는것보다, 처음부터 set 쓰는게 나음
for i in range(n):
  for j in range(i+1, n): # i 뒤부터 반복문을 돌려서 서로 다른 수를 뽑게 하기 위해 설정
    for m in range(j+1, n): # m은 j 뒤부터 반복문을 돌림 -&gt; 서로 다른 수
      res.add(a[i] + a[j] + a[m]) # list자료형은 append 함수를 쓰지만 set자료형은 add함수를 씀
res = list(res)
res.sort(reverse=True) # sort에 파라미터값을 안주면, 오름차순이라 내림차순 정렬하기위헤 reverse 인자를줌
print(res[k-1])
</code></pre>]]></content><author><name>Ino</name></author><category term="algorithm" /><category term="Python" /><category term="algorithm" /><summary type="html"><![CDATA[문제는 너무 자세하게 기술하지 않음 출처 : 인프런 - 파이썬 알고리즘 문제풀이 (코딩테스트 대비) by 김태원 강사님]]></summary></entry><entry><title type="html">대표값 for Python</title><link href="http://localhost:4000/algorithm/2022/07/30/%EB%8C%80%ED%91%9C%EA%B0%92.html" rel="alternate" type="text/html" title="대표값 for Python" /><published>2022-07-30T00:00:00+09:00</published><updated>2022-07-30T00:00:00+09:00</updated><id>http://localhost:4000/algorithm/2022/07/30/%EB%8C%80%ED%91%9C%EA%B0%92</id><content type="html" xml:base="http://localhost:4000/algorithm/2022/07/30/%EB%8C%80%ED%91%9C%EA%B0%92.html"><![CDATA[<blockquote>
  <p>문제는 너무 자세하게 기술하지 않음
출처 : 인프런 - 파이썬 알고리즘 문제풀이 (코딩테스트 대비) by 김태원 강사님</p>
</blockquote>

<h2 id="문제">문제</h2>
<p>N명의 학생의 수학점수가 주어집니다. N명의 학생들의 평균(소수 첫째자리 반올림)을 구하고,     N명의 학생 중 평균에 가장 가까운 학생은 몇 번째 학생인지 출력하는 프로그램을 작성하세요.</p>

<h4 id="입력">입력</h4>
<p>첫줄에 자연수 N(5&lt;=N&lt;=100)이 주어지고, 두 번째 줄에는 각 학생의 수학점수인 N개의 자연 수가 주어집니다.    학생의 번호는 앞에서부터 1로 시작해서 N까지이다.</p>

<h4 id="출력">출력</h4>
<p>첫줄에 평균과 평균에 가장 가까운 학생의 번호를 출력한다.  <br />
평균은 소수 첫째 자리에서 반올림합니다.</p>

<pre><code class="language-Python">n = int(input("n을 입력하시오 : "))
a = list(map(int, input().split()))
min = 2147000000 # int 형의 가장 큰 값을 최솟값에 넣어서 이후 진행되는 if 비교문에서 항상 참이되게 설정함
ave = round(sum(a)/n) # round 는 소수첫째자리에서 반올림함 sum함수는 a리스트에 있는 모든값을 다 더함
for index,x in enumerate(a): # index값이 0부터 시작하는 index고, x가 a list에 있는 값들이 하나씩 들어간다.
  tmp = abs(x - ave)
  if tmp &lt; min:
    min = tmp
    score = x
    res = index+1 # index는 0부터 시작이기때문에 학생이 몇번째인지 알려면 +1을 해주어야함
  elif tmp == min:
    if x &gt; score:
      score = x
      res =index+1

print(ave, res)


</code></pre>

<h4 id="설명">설명</h4>
<p>n명의 학생의 평균을 구하고, 그 학생이 배열에서 몇 번째에 위치되어있는지만 찾으면 되는 문제다. <br />
평균을 나타내는 ave변수를 round랑 sum 내장함수를 이용해서
<code class="language-plaintext highlighter-rouge">sum : 리스트에 있는 원소의 합을 반환해준다.</code>
<code class="language-plaintext highlighter-rouge">round : round(실수,n) 이런식으로 쓰면 첫번째 인자를 n번째 소수점에서 반올림한다. (음수를 파라미터로 넣으면 소수점이 아닌 정수에서도 해당위치에서 반올림할 수 있다.) 단, 두번째 파라미터값을 안넣으면 디폴트값으로 소숫점 첫째자리에서 반올림한다.</code> <br />
평균을 구하고, a의 index값과 밸류값을 함께 enumerate를 이용해서 반복문을 돌린다.  <br />
<code class="language-plaintext highlighter-rouge">enumerate는 "열거하다"라는 뜻이다. 이 함수는 순서가 있는 자료형(리스트, 튜플, 문자열)을 입력으로 받아 인덱스 값을 포함하는 enumerate 객체를 돌려준다.</code>
tmp에는 각각의 학생들 평균인 x값에서 평균을 뺀 값을 절댓값으로 만들어서 넣는다.  <br />
tmp가 기존 min 보다 작으면, 해당tmp으로 min을 대체한다. <br />
그렇게 min을 대체하게 된 성적점수와 index를 각각의 변수에 넣는다.</p>]]></content><author><name>Ino</name></author><category term="algorithm" /><category term="Python" /><category term="algorithm" /><summary type="html"><![CDATA[문제는 너무 자세하게 기술하지 않음 출처 : 인프런 - 파이썬 알고리즘 문제풀이 (코딩테스트 대비) by 김태원 강사님]]></summary></entry></feed>