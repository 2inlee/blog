<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-12-24T01:45:58+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Inlee’s Blog</title><subtitle>All of Code</subtitle><author><name>inlee</name></author><entry><title type="html">(JPA-4)MappedSuperclass 공통매핑정보의 재사용</title><link href="http://localhost:4000/spring/2023/12/24/Superclass.html" rel="alternate" type="text/html" title="(JPA-4)MappedSuperclass 공통매핑정보의 재사용" /><published>2023-12-24T00:00:00+09:00</published><updated>2023-12-24T00:00:00+09:00</updated><id>http://localhost:4000/spring/2023/12/24/Superclass</id><content type="html" xml:base="http://localhost:4000/spring/2023/12/24/Superclass.html"><![CDATA[<h2 id="mappedsuperclass-공통-매핑-정보의-재사용">MappedSuperclass: 공통 매핑 정보의 재사용</h2>

<h3 id="개요">개요</h3>

<p><code class="language-plaintext highlighter-rouge">MappedSuperclass</code>는 JPA에서 상속 관계 매핑이 아닌 공통 매핑 정보의 재사용을 위해 사용됩니다. <br />
이 방법은 데이터베이스 설계와 객체지향 설계의 불일치 문제를 해결하는 데 도움을 줍니다.</p>

<h3 id="주요-특징">주요 특징</h3>
<ul>
  <li>
    <p>공통 매핑 정보 제공: @MappedSuperclass로 지정된 클래스는 데이터베이스 테이블로 직접 매핑되지 않습니다.
대신, 이 클래스에 정의된 매핑 정보(필드, 관계, 메서드 등)는 상속받는 자식 클래스에게 상속됩니다.</p>
  </li>
  <li>
    <p>엔티티가 아님: @MappedSuperclass로 지정된 클래스는 엔티티가 아닙니다. 즉, EntityManager를 통해 직접 쿼리하거나 데이터베이스 작업을 할 수 없습니다.</p>
  </li>
  <li>
    <p>상속받는 자식 클래스들의 매핑 정보: 자식 클래스들은 @MappedSuperclass에서 정의된 필드나 메서드를 상속받아 사용할 수 있으며, 각각 독립적인 테이블로 매핑됩니다.</p>
  </li>
  <li>
    <p>재사용성과 유지보수성 향상: 공통적인 매핑 정보를 @MappedSuperclass에 정의함으로써, 코드의 재사용성과 유지보수성이 향상됩니다.</p>
  </li>
</ul>

<h3 id="사용-예시">사용 예시</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@MappedSuperclass</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">BaseEntity</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">IDENTITY</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
    <span class="c1">// 공통으로 사용되는 필드 및 메서드</span>
    <span class="c1">// getters and setters</span>
<span class="o">}</span>

<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="kd">extends</span> <span class="nc">BaseEntity</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>
    <span class="c1">// 추가적인 필드 및 메서드</span>
    <span class="c1">// getters and setters</span>
<span class="o">}</span>

<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="kd">extends</span> <span class="nc">BaseEntity</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">productName</span><span class="o">;</span>
    <span class="c1">// 추가적인 필드 및 메서드</span>
    <span class="c1">// getters and setters</span>
<span class="o">}</span>

</code></pre></div></div>
<p>이 예시에서 BaseEntity 클래스는 @MappedSuperclass로 지정되어 있으며, User와 Product 엔티티가 이를 상속받습니다.   <br />
BaseEntity의 id 필드와 관련 메서드는 User와 Product 엔티티에 모두 상속되며, 각각의 엔티티는 자신만의 테이블로 매핑됩니다.</p>

<h2 id="일반적인-jpa에서의-extend--상속을-쓰는-경우">일반적인 JPA에서의 extend : 상속을 쓰는 경우</h2>

<h3 id="entity-상속">Entity 상속</h3>
<p>한 엔티티 클래스가 다른 엔티티 클래스를 상속할 때 사용합니다.   <br />
상속받는 클래스는 @Entity 어노테이션으로 표시되며, 데이터베이스 테이블과 매핑됩니다.   <br />
사용되는 상속 전략에는 단일 테이블 상속(SINGLE_TABLE), 조인 테이블 상속(JOINED), 테이블 당 클래스 상속(TABLE_PER_CLASS) 등이 있습니다.</p>

<h3 id="mappedsuperclass-상속">MappedSuperclass 상속</h3>
<p>@MappedSuperclass 어노테이션이 적용된 클래스를 상속받을 때 사용됩니다.  <br />
여러 엔티티 클래스에서 공통으로 사용되는 매핑 정보(필드, 메서드 등)를 정의하는 데 사용됩니다.   <br />
상속받는 엔티티들은 @MappedSuperclass에서 정의된 정보를 재사용할 수 있으며, 각각 독립적인 테이블로 매핑됩니다.</p>

<h2 id="결론">결론</h2>
<p>MappedSuperclass는 JPA에서 매핑 정보의 중복을 줄이고, 코드의 재사용성 및 유지보수성을 향상시키는 유용한 방법입니다. <br />
하지만, 이는 엔티티가 아니므로 데이터베이스와의 직접적인 상호작용은 할 수 없습니다.   <br />
따라서, 이를 사용할 때는 엔티티와의 차이점을 명확히 이해하고 적절히 활용해야 합니다.</p>]]></content><author><name>Ino</name></author><category term="spring" /><category term="java" /><category term="spring" /><summary type="html"><![CDATA[MappedSuperclass: 공통 매핑 정보의 재사용]]></summary></entry><entry><title type="html">(JPA-3)고급매핑 상속관계매핑</title><link href="http://localhost:4000/spring/2023/12/23/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84.html" rel="alternate" type="text/html" title="(JPA-3)고급매핑 상속관계매핑" /><published>2023-12-23T00:00:00+09:00</published><updated>2023-12-23T00:00:00+09:00</updated><id>http://localhost:4000/spring/2023/12/23/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84</id><content type="html" xml:base="http://localhost:4000/spring/2023/12/23/%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84.html"><![CDATA[<h4 id="들어가기-전에">들어가기 전에</h4>

<p><a href="https://blog.inlee.kr/spring/2023/12/09/%EC%97%B0%EA%B4%80%EA%B4%B8%EA%B3%84%EB%A7%A4%ED%95%91.html">이전글</a> 연관관계 매핑 포스트를 보고 오면 좋습니다.</p>

<h2 id="고급-매핑-상속관계-매핑">고급 매핑: 상속관계 매핑</h2>

<p>객체지향 프로그래밍에서 상속은 중요한 개념입니다.   <br />
이를 데이터베이스와 연동할 때, 어떻게 효과적으로 구현할 수 있을까요?  <br />
JPA(Java Persistence API)를 사용하면, 슈퍼타입과 서브타입 관계를 물리 모델로 효율적으로 변환할 수 있습니다.   <br />
이를 위한 세 가지 전략이 있습니다:</p>

<p>각각의 테이블로 변환 (조인 전략)  <br />
통합 테이블로 변환 (단일 테이블 전략) <br />
서브타입 테이블로 전환 (구현 클래스마다 테이블 전략)  <br />
주요 어노테이션 <br />
이러한 전략을 구현하기 위해 JPA에서는 다음과 같은 어노테이션을 제공합니다:</p>

<p>@Inheritance(strategy=InheritanceType.XXX):</p>

<p>JOINED: 조인 전략 <br />
SINGLE_TABLE: 단일 테이블 전략  <br />
TABLE_PER_CLASS: 구현 클래스마다 테이블 전략  <br />
@DiscriminatorColumn(name=”DTYPE”): 주로 부모 클래스에서 지정</p>

<p>@DiscriminatorValue(“XXX”): 주로 자식 클래스에서 지정</p>

<p>예를 들어, Animal이라는 부모 클래스와 Cat, Dog라는 자식 클래스가 있다고 가정해 봅시다.  <br />
이 경우, Animal 클래스에는 @DiscriminatorColumn을 설정하고, Cat과 Dog 클래스에는 각각 다른 @DiscriminatorValue를 설정합니다.  <br />
이렇게 하면 JPA는 Animal 테이블의 각 행이 Cat인지 Dog인지를 구별할 수 있습니다.</p>

<p>예시: Animal, Cat, Dog 클래스</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="nd">@Entity</span>
<span class="nd">@Inheritance</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">InheritanceType</span><span class="o">.</span><span class="na">JOINED</span><span class="o">)</span>
<span class="nd">@DiscriminatorColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"ANIMAL_TYPE"</span><span class="o">,</span> <span class="n">discriminatorType</span> <span class="o">=</span> <span class="nc">DiscriminatorType</span><span class="o">.</span><span class="na">STRING</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">IDENTITY</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="c1">// getters and setters</span>
<span class="o">}</span>

<span class="nd">@Entity</span>
<span class="nd">@DiscriminatorValue</span><span class="o">(</span><span class="s">"CAT"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Cat</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">likesMilk</span><span class="o">;</span>
    <span class="c1">// getters and setters</span>
<span class="o">}</span>

<span class="nd">@Entity</span>
<span class="nd">@DiscriminatorValue</span><span class="o">(</span><span class="s">"DOG"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Dog</span> <span class="kd">extends</span> <span class="nc">Animal</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">breed</span><span class="o">;</span>
    <span class="c1">// getters and setters</span>
<span class="o">}</span>

</code></pre></div></div>

<p>Cat 클래스와 Dog 클래스는 각각 Animal 클래스를 상속받으며, @DiscriminatorValue를 사용해 구별자 값을 설정합니다. <br />
이 구조를 사용하면, 각 자식 엔티티는 자신의 테이블을 가지며, 부모 테이블(Animal)과 조인됩니다.  <br />
@DiscriminatorColumn은 각 엔티티 인스턴스의 타입을 식별하는 데 사용됩니다.</p>

<h3 id="전략별-특징과-사용-시-고려사항">전략별 특징과 사용 시 고려사항</h3>
<ul>
  <li>
    <p>조인 전략(JOINED):  <br />
각 클래스의 데이터를 별도의 테이블에 분리하여 저장합니다. <br />
데이터 모델의 정규화를 유지할 수 있으나, 조인을 필요로 하여 조회 성능에 영향을 줄 수 있습니다.</p>
  </li>
  <li>
    <p>단일 테이블 전략(SINGLE_TABLE): <br />
모든 엔티티가 하나의 테이블에 저장됩니다. <br />
조회 성능은 빠르나, 테이블이 커질 수 있으며 null 제약조건 관리에 주의가 필요합니다.</p>
  </li>
  <li>
    <p>구현 클래스마다 테이블 전략(TABLE_PER_CLASS): <br />
각 구현 클래스마다 별도의 테이블을 가집니다.  <br />
서브 타입을 명확하게 구분할 수 있지만, 여러 테이블을 함께 조회할 때 성능 저하가 발생할 수 있습니다.</p>
  </li>
</ul>

<h3 id="결론">결론</h3>
<p>상속 관계 매핑은 JPA를 사용하여 객체지향 모델을 데이터베이스 설계에 효과적으로 통합할 수 있는 방법을 제공합니다.  <br />
실제 비즈니스적으로 중요하고 복잡할수록 조인 전략을 많이 사용한다고 합니다. <br />
각 전략은 특정 상황에 적합한 장단점을 가지고 있으므로, 상황에 따라 적절한 전략을 선택하는 것이 중요합니다.</p>]]></content><author><name>Ino</name></author><category term="spring" /><category term="java" /><category term="spring" /><summary type="html"><![CDATA[들어가기 전에]]></summary></entry><entry><title type="html">(JPA-2)JPA 연관관계 매핑과 연관관계의 주인</title><link href="http://localhost:4000/spring/2023/12/09/%EC%97%B0%EA%B4%80%EA%B4%B8%EA%B3%84%EB%A7%A4%ED%95%91.html" rel="alternate" type="text/html" title="(JPA-2)JPA 연관관계 매핑과 연관관계의 주인" /><published>2023-12-09T00:00:00+09:00</published><updated>2023-12-09T00:00:00+09:00</updated><id>http://localhost:4000/spring/2023/12/09/%EC%97%B0%EA%B4%80%EA%B4%B8%EA%B3%84%EB%A7%A4%ED%95%91</id><content type="html" xml:base="http://localhost:4000/spring/2023/12/09/%EC%97%B0%EA%B4%80%EA%B4%B8%EA%B3%84%EB%A7%A4%ED%95%91.html"><![CDATA[<h4 id="들어가기-전에">들어가기 전에</h4>

<p><a href="https://blog.inlee.kr/spring/2023/12/02/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8.html">이전글</a> 영속성 컨텍스트 포스트를 보고 오면 좋습니다.</p>

<h2 id="연관관계-매핑-기초">연관관계 매핑 기초</h2>

<p>ORM을 사용하는 데 있어서 가장 중요한 개념 중 하나는 객체와 테이블의 차이를 이해하는 것이라고 생각한다.  <br />
사실 DB만 잘 배우는 것도 쉽지 않은데, 안타깝게도 ORM을 사용하려면 기본적인 DB 지식이 있어야 한다.</p>

<ul>
  <li>방향(Direction): 단방향, 양방향</li>
  <li>다중성(Multiplicity): 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M) 이해</li>
  <li>연관관계의 주인(Owner): 객체 양방향 연관관계는 관리주인이 필요</li>
</ul>

<h3 id="1-단방향-연관관계-n1">1. 단방향 연관관계 (N:1)</h3>
<p>예를 들어, 주문(Order)이 고객(Customer)에게 속하는 경우를 생각해볼 수 있습니다. 여기서 Order 클래스는 Customer 클래스를 참조합니다.</p>

<p>Customer 클래스</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Customer</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="c1">// 기타 필드 및 메서드</span>
<span class="o">}</span>

</code></pre></div></div>

<p>Order 클래스</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="nd">@ManyToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"customer_id"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">Customer</span> <span class="n">customer</span><span class="o">;</span>
    <span class="c1">// 기타 필드 및 메서드</span>
<span class="o">}</span>

</code></pre></div></div>
<p>@ManyToOne 애노테이션은 Order 클래스가 Customer에 대해 다대일(N:1) 관계임을 나타냅니다. <br />
@JoinColumn은 실제 데이터베이스의 외래 키 이름을 지정합니다.</p>

<h3 id="2-양방향-연관관계-1n">2. 양방향 연관관계 (1:N)</h3>

<p>양방향 연관관계에서는 Customer 클래스도 Order를 참조할 수 있습니다. 이 경우, 연관관계의 주인은 Order 클래스입니다.</p>

<p>Customer 클래스</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Customer</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="c1">// mappedBy를 넣어줘야 된다. JoinColumn만 해서는 안된다.</span>
    <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"customer"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="n">orders</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="c1">// 기타 필드 및 메서드</span>
<span class="o">}</span>

</code></pre></div></div>

<h4 id="2-1-연관관계의-주인과-mappedby">2-1 연관관계의 주인과 mappedBy</h4>

<p>@OneToMany 애노테이션에서 mappedBy 속성은 연관관계의 주인을 지정합니다.   <br />
여기서 “customer”는 Order 클래스에서 Customer를 참조하는 필드 이름입니다.</p>

<p>DB 테이블에서는 연관관계 주인 개념이 필요가 없다.</p>
<blockquote>
  <p>외래키만 넣어두면 양방향으로 다 조회가 가능하기 때문에</p>
</blockquote>

<p>객체는 양방향 연관관계가 아니라, 사실 단방향 연관관계 2개이다.</p>

<ul>
  <li>객체 연관관계 = 2개</li>
  <li>고객 -&gt; 주문 연관관계 1개(단방향)</li>
  <li>
    <p>주문 -&gt; 고객 연관관계 1개(단방향)</p>
  </li>
  <li>테이블 연관관계 = 1개</li>
  <li>고객 &lt;-&gt; 주문 연관관계 1개(양방향)</li>
</ul>

<p>근데 객체는 mappedBy를 넣어서 주인을 설정해줘야 한다.</p>
<blockquote>
  <p>해당 속성은 비주인쪽에서 작성되어야 한다.</p>
</blockquote>

<ul>
  <li>
    <p>연관관계의 주인(Owner)
양방향 매핑 규칙</p>
  </li>
  <li>객체의 두 관계중 하나를 연관관계의 주인으로 지정</li>
  <li>연관관계의 주인만이 외래 키를 관리(등록, 수정) 가능</li>
  <li>주인이 아닌쪽은 읽기만 가능</li>
  <li>주인은 maappedBy 속성 사용 X</li>
  <li>
    <p>주인이 아니면 mappedBy 속성으로 주인 지정</p>
  </li>
  <li>
    <p>누구를 주인으로 잡아야 하는가?</p>
  </li>
  <li>외래 키가 있는 곳을 주인으로 정해야 한다.</li>
  <li>여기서는 Order.customer 가 연관관계의 주인이 된다.</li>
  <li>비즈니스 로직을 기준으로 연관관계의 주인을 설정하면 안된다.</li>
</ul>

<h3 id="3-일대일-연관관계-11">3. 일대일 연관관계 (1:1)</h3>
<p>각 사용자(User)가 사용자 프로필(UserProfile)을 가지는 경우를 예로 들 수 있습니다.</p>

<p>User 클래스</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">username</span><span class="o">;</span>

    <span class="nd">@OneToOne</span>
    <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"profile_id"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">UserProfile</span> <span class="n">profile</span><span class="o">;</span>
    <span class="c1">// 기타 필드 및 메서드</span>
<span class="o">}</span>

</code></pre></div></div>
<p>UserProfile 클래스</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserProfile</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">phone</span><span class="o">;</span>
    <span class="c1">// 기타 필드 및 메서드</span>
<span class="o">}</span>

</code></pre></div></div>
<p>@OneToOne 애노테이션은 일대일 관계를 나타냅니다. 여기서도 @JoinColumn을 사용하여 외래 키를 지정합니다.</p>

<h3 id="4-다대다-연관관계-nm">4. 다대다 연관관계 (N:M)</h3>

<p>다대다 관계는 실제로 사용될 때 중간 엔티티(Join Table)를 통해 구현되곤 합니다. 예를 들어, 학생(Student)과 과목(Course) 간의 관계를 생각해 볼 수 있습니다.</p>

<p>Student 클래스</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Student</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

    <span class="nd">@ManyToMany</span>
    <span class="nd">@JoinTable</span><span class="o">(</span>
      <span class="n">name</span> <span class="o">=</span> <span class="s">"student_course"</span><span class="o">,</span>
      <span class="n">joinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"student_id"</span><span class="o">),</span>
      <span class="n">inverseJoinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"course_id"</span><span class="o">)</span>
    <span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Course</span><span class="o">&gt;</span> <span class="n">courses</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="c1">// 기타 필드 및 메서드</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Course 클래스</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Course</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span>
    <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">courseName</span><span class="o">;</span>

    <span class="nd">@ManyToMany</span><span class="o">(</span><span class="n">mappedBy</span> <span class="o">=</span> <span class="s">"courses"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Student</span><span class="o">&gt;</span> <span class="n">students</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
    <span class="c1">// 기타 필드 및 메서드</span>
<span class="o">}</span>

</code></pre></div></div>
<p>@ManyToMany 애노테이션을 사용하고, @JoinTable을 통해 중간 테이블을 지정합니다. 이 중간 테이블은 두 엔티티 간의 연관관계를 관리합니다.</p>

<h2 id="양방향-매핑-정리">양방향 매핑 정리</h2>
<ul>
  <li>단방향 매핑만으로도 이미 연관관계 매핑은 완료</li>
  <li>양방향 매핑은 반대 방향으로 조회 (객체 그래프 탐색) 기능이 추가된 것 뿐</li>
  <li>JPQL에서 역방향으로 탐색할 일이 많음</li>
  <li>단방향 매핑을 잘 하고 양방향은 필요할 때 추가해도 됨 (테이블 영향을 주지 않음)</li>
</ul>]]></content><author><name>Ino</name></author><category term="spring" /><category term="java" /><category term="spring" /><summary type="html"><![CDATA[들어가기 전에]]></summary></entry><entry><title type="html">(JPA-1)JPA와 영속성 컨텍스트</title><link href="http://localhost:4000/spring/2023/12/02/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8.html" rel="alternate" type="text/html" title="(JPA-1)JPA와 영속성 컨텍스트" /><published>2023-12-02T00:00:00+09:00</published><updated>2023-12-02T00:00:00+09:00</updated><id>http://localhost:4000/spring/2023/12/02/%EC%98%81%EC%86%8D%EC%84%B1%20%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8</id><content type="html" xml:base="http://localhost:4000/spring/2023/12/02/%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8.html"><![CDATA[<h4 id="들어가기-전에">들어가기 전에</h4>

<p>사실 스프링 공부를 여러번 시도 했었다.  <br />
HTTP, WAS, DB 등 백앤드에 관련된 지식이 없을 때 무작정 인프런에서 유명하다는 강사님의 인강을 보면서 따라 쳤는데
강의 내용의 반의 반도 습득하지 못했었다.  <br />
그렇게 두 번, 세 번 전체강의를 돌려보았고 결국 완벽한 이해는 못한 채 다른 프로젝트들을 시작했다.  <br />
Flask, Nest.js 등의 다른 프레임워크를 사용하다가 현업에서 가장 많이 쓰고 강력한 무기인 Spring을 다 씹어먹지 못한 게 너무 한이되어 다시 처음부터 개념을 씹어먹을거라는 각오로 블로그 글을 작성하면서 다시 공부하기로 했다. <br />
그래서, Code-based인 다른 포스트랑은 다르게 Spring은 내가 이해하고 추가적으로 궁금했었던 개념들을 위주로 글을 써내려가려고 한다.</p>

<p>추가로, 제목 앞에 붙는 넘버링은 Spring 공부 순서에 따라 정리하는 순으로 정리되며, 객관적으로 중요한 내용이더라도
필자가 기존에 제대로 이해하고 있었고 다시 공부하면서 배운 점이 없다면 굳이 포스팅으로 남기지 않으려고 한다.</p>

<h2 id="jpa는-왜-써야할까">JPA는 왜 써야할까?</h2>

<p>실제 프로젝트를 하다보면 DB Table들이 계속 많아지고 OOP를 준수하면서 코딩을 할 수록 매핑작업이 끝없이 늘어나게 된다.  <br />
그래서 ORM (Object Relational Mapping) 기술을 활용하여 코딩을 하면 조금 더 개발자답게(?) 코딩할 수 있게 된다.</p>

<p>레거시하게 JDBC에서 유저를 조회하는 쿼리문을 작성하는 예시를 보면 아래와 같다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LegacyJdbcExample</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">User</span> <span class="nf">getUserById</span><span class="o">(</span><span class="kt">long</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">User</span> <span class="n">user</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">Connection</span> <span class="n">connection</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">PreparedStatement</span> <span class="n">preparedStatement</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="nc">ResultSet</span> <span class="n">resultSet</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

        <span class="k">try</span> <span class="o">{</span>
            <span class="nc">String</span> <span class="n">url</span> <span class="o">=</span> <span class="s">"jdbc:mysql://localhost:3306/database_name"</span><span class="o">;</span>
            <span class="nc">String</span> <span class="n">username</span> <span class="o">=</span> <span class="s">"username"</span><span class="o">;</span>
            <span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="s">"password"</span><span class="o">;</span>

            <span class="n">connection</span> <span class="o">=</span> <span class="nc">DriverManager</span><span class="o">.</span><span class="na">getConnection</span><span class="o">(</span><span class="n">url</span><span class="o">,</span> <span class="n">username</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
            <span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">"SELECT * FROM users WHERE id = ?"</span><span class="o">;</span>
            <span class="n">preparedStatement</span> <span class="o">=</span> <span class="n">connection</span><span class="o">.</span><span class="na">prepareStatement</span><span class="o">(</span><span class="n">sql</span><span class="o">);</span>
            <span class="n">preparedStatement</span><span class="o">.</span><span class="na">setLong</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">userId</span><span class="o">);</span>

            <span class="n">resultSet</span> <span class="o">=</span> <span class="n">preparedStatement</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">();</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">resultSet</span><span class="o">.</span><span class="na">next</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">user</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">User</span><span class="o">();</span>
                <span class="n">user</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="n">resultSet</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="s">"id"</span><span class="o">));</span>
                <span class="n">user</span><span class="o">.</span><span class="na">setName</span><span class="o">(</span><span class="n">resultSet</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"name"</span><span class="o">));</span>
                <span class="c1">// ... set other fields</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">SQLException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
        <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
            <span class="k">try</span> <span class="o">{</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">resultSet</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">resultSet</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">preparedStatement</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">preparedStatement</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                <span class="k">if</span> <span class="o">(</span><span class="n">connection</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="n">connection</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
            <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">SQLException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">e</span><span class="o">.</span><span class="na">printStackTrace</span><span class="o">();</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">user</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>반면에 JPA로 같은 기능을 하는 코드를 작성하면,</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JpaExample</span> <span class="o">{</span>
    
    <span class="nd">@PersistenceContext</span>
    <span class="kd">private</span> <span class="nc">EntityManager</span> <span class="n">entityManager</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nc">User</span> <span class="nf">getUserById</span><span class="o">(</span><span class="kt">long</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">entityManager</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">User</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">userId</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>이런식으로 Spring에서 제공해주는 EntityManager를 사용해 빠른 개발을 할 수 있다.</p>

<p>JPA는 Java애플리케이션과 JDBC 사이에서 동작하며, 이를 정확히 이해하려면 엔티티 매니저와 영속성 컨텍스트를 이해해야 한다.</p>

<h2 id="엔티티-매니저-팩토리와-엔티티-매니저">엔티티 매니저 팩토리와 엔티티 매니저</h2>

<p>사용자가 요청을 보낼 때 마다 EntityManagerFactory가 EntityManager 객체를 생성한다.  <br />
그렇게 생성된 EntityManager 객체는 ConnectionPool을 통해 DB에 저장, 조회된다.</p>

<h3 id="영속성-컨텍스트">영속성 컨텍스트</h3>

<p>엔티티 매니저를 통해서 영속성 컨텍스트에 접근할 수 있다.  <br />
Spring과 같은 프레임워크에서는 엔티티 매니저와 영속성 컨텍스트가 N:1 관계로,  <br />
각각의 EntityManager들이 하나의 PersistenceContext와 매핑되어 있는 구조이다.</p>

<p>엔티티의 생명주기에는 아래와 같은 상태가 존재한다.</p>

<ul>
  <li>
    <dl>
      <dt>비영속 (new/transient)</dt>
      <dd>영속성 컨텍스트와 전혀 관계가 없는 새로운 상태</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt>영속 (managed)</dt>
      <dd>영속성 컨텍스트에 관리되는 상태</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt>준영속 (detached)</dt>
      <dd>영속성 컨텍스트에 저장되었다가 분리된 상태</dd>
    </dl>
  </li>
  <li>
    <dl>
      <dt>삭제 (removed)</dt>
      <dd>삭제된 상태</dd>
    </dl>
  </li>
</ul>

<h4 id="비영속">비영속</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 단순히 객체를 생성하기만 한 상태</span>
<span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
<span class="n">member</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="s">"member1"</span><span class="o">);</span>
<span class="n">member</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"회원1"</span><span class="o">);</span>
</code></pre></div></div>

<h4 id="영속">영속</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Member</span><span class="o">();</span>
<span class="n">member</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="s">"member1"</span><span class="o">);</span>
<span class="n">member</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"회원1"</span><span class="o">);</span>

<span class="nc">EntitiyManager</span> <span class="n">em</span> <span class="o">=</span> <span class="n">emf</span><span class="o">.</span><span class="na">createEntityManager</span><span class="o">();</span>
<span class="n">em</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">().</span><span class="na">begin</span><span class="o">();</span>

<span class="c1">// 객체를 저장한 상태 (영속)</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
</code></pre></div></div>

<h4 id="준영속-삭제">준영속, 삭제</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 영속성 컨텍스트에서 분리 (준영속)</span>
<span class="n">em</span><span class="o">.</span><span class="na">detach</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 객체를 삭제한 상태 (삭제)</span>
<span class="n">em</span><span class="o">.</span><span class="na">detach</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
</code></pre></div></div>

<p>결국 영속성 컨텍스트가 프레임워크 내에서 객체를 관리해주는 역할을 한다.</p>

<h3 id="영속성-컨텍스트의-이점">영속성 컨텍스트의 이점</h3>

<ul>
  <li>1차 캐시</li>
  <li>동일성 보장</li>
  <li>트랜잭션을 지원하는 쓰기 지연</li>
  <li>변경 감지(Dirty Checking)</li>
  <li>지연로딩(Lazy Loading)</li>
</ul>

<h4 id="1차-캐시">1차 캐시</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 1차 캐시에 저장됨</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
<span class="c1">// 1차 캐시에서 조회</span>
<span class="nc">Member</span> <span class="n">findMember</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>
</code></pre></div></div>

<p>이런식으로 사용했을 때 DB에서 find 하는 게 아니라, 1차 캐시에서 조회하기 때문에 빠른 응답을 제공할 수 있다.</p>

<p>만약 1차 캐시에 없다면, 이후 DB에서 조회를 하고 1차 캐시에 저장 후 반환하게 된다.</p>

<p>처음 공부할 때 Spring이 알아서 한번 조회했던 객체를 entityManager 내에 1차 캐시에 저장하면,   <br />
Redis (REmote Dictionary Server)는 Spring을 쓰면서 MSA로 구성할 때 메인노드로 쓸 때를 제외하면 굳이 Spring과 레디스를
같이 쓸 필요는 없겠네..? 라는 생각을 했었다.</p>

<p>그리고 의문이 1분만에 풀리는데, entityManager는 보통 한번 사용되고 바로 close 되는데, close되면서 1차 캐시에 있던 key-value가
날라가는 것이다.</p>

<p>그러니까 객체가 호출되면서 잠깐만 존재했다가 사라지는 존재였던 것이다.</p>

<h4 id="동일성-보장">동일성 보장</h4>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Member</span> <span class="n">a</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>
<span class="nc">Member</span> <span class="n">b</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"member1"</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="o">);</span> 
<span class="c1">// 동일성 비교 true</span>
</code></pre></div></div>

<p>실제로 여러 번의 조회를 하더라도 트랜잭션 격리 수준을 DB가 아닌 Java 애플리케이션 차원에서 제공하기 때문에 동일성을 보장 받는다.</p>

<h4 id="트랜잭션을-지원하는-쓰기-지연">트랜잭션을 지원하는 쓰기 지연</h4>

<p>엔티티 등록 : 트랜잭션을 지원하는 쓰기 지연</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">EntityManager</span> <span class="n">em</span> <span class="o">=</span> <span class="n">emf</span><span class="o">.</span><span class="na">createEntityManager</span><span class="o">();</span>
<span class="nc">EntityTransaction</span> <span class="n">transaction</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">();</span>
<span class="c1">// 엔티티 매니저는 데이터 변경시 트랜잭션을 시작해야 한다.</span>
<span class="n">transaction</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span> <span class="c1">// [트랜잭션] 시작</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">memberA</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">memberB</span><span class="o">);</span>
<span class="c1">// 여기까지 INSERT SQL을 데이터베이스에 보내지 않는다.</span>
<span class="c1">// 커밋하는 순간 데이터베이스에 INSERT SQL을 보낸다.</span>
<span class="n">transaction</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span> <span class="c1">// [트랜잭션] 커밋</span>
</code></pre></div></div>

<p>트랜잭션이 커밋되기 전까지는 SQL을 보내지 않음으로 한번에 모아서 SQL을 호출해서 성능적인 부분에서 이점을 챙길 수 있다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">memberA</span><span class="o">);</span>
<span class="n">em</span><span class="o">.</span><span class="na">persist</span><span class="o">(</span><span class="n">memberB</span><span class="o">);</span>
<span class="c1">// 이때까지는 영속성 컨텍스트 내에 있는 1차 캐시에 저장만 하고 있다.</span>
</code></pre></div></div>

<p>추가로 commit()을 하더라도 영속 컨텍스트에 있는 1차 캐시가 날라가지는 않고, <code class="language-plaintext highlighter-rouge">em.close</code>를 해서 entityManager를 삭제해야 캐시가 날라간다.</p>

<h4 id="변경-감지dirty-checking">변경 감지(Dirty Checking)</h4>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">EntityManager</span> <span class="n">em</span> <span class="o">=</span> <span class="n">emf</span><span class="o">.</span><span class="na">createEntityManager</span><span class="o">();</span>
<span class="nc">EntityTransaction</span> <span class="n">transaction</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">getTransaction</span><span class="o">();</span>
<span class="n">transaction</span><span class="o">.</span><span class="na">begin</span><span class="o">();</span> <span class="c1">// [트랜잭션] 시작</span>
<span class="c1">// 영속 엔티티 조회</span>
<span class="nc">Member</span> <span class="n">memberA</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Member</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="s">"memberA"</span><span class="o">);</span>
<span class="c1">// 영속 엔티티 데이터 수정</span>
<span class="n">memberA</span><span class="o">.</span><span class="na">setUsername</span><span class="o">(</span><span class="s">"hi"</span><span class="o">);</span>
<span class="n">memberA</span><span class="o">.</span><span class="na">setAge</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span>
<span class="c1">//em.update(member) 이런 코드가 있어야 하지 않을까?</span>
<span class="n">transaction</span><span class="o">.</span><span class="na">commit</span><span class="o">();</span> <span class="c1">// [트랜잭션] 커밋</span>
</code></pre></div></div>

<p>1차 캐시에 있는 member Entity와 스냅샷을 비교하여 UPDATE SQL을 쓰기지연 SQL 저장소에서 생성하기 때문에 UPDATE문이 필요가 없다.</p>

<h3 id="플러시-flush">플러시 Flush</h3>

<ul>
  <li>영속성 컨텍스트의 변경내용을 데이터베이스에 동기화</li>
</ul>

<h4 id="영속성-컨텍스트를-플러시하는-방법">영속성 컨텍스트를 플러시하는 방법</h4>

<ul>
  <li>em.flush() - 직접 호출</li>
  <li>트랜잭션 커밋 - 플러시 자동 호출</li>
  <li>JPQL 쿼리 실행 - 플러시 자동 호출</li>
</ul>

<h4 id="플러시-특성">플러시 특성</h4>

<ul>
  <li>영속성 컨텍스트를 비우지 않음</li>
  <li>영속성 컨텍스트의 변경내용을 데이터베이스에 동기화</li>
  <li>트랜잭션이라는 작업 단위가 중요 -&gt; 커밋 직전에만 동기화 하면 됨</li>
</ul>

<p>플러시 모드 옵션은 Default 상태에서 크게 건들 일이 없다.</p>]]></content><author><name>Ino</name></author><category term="spring" /><category term="java" /><category term="spring" /><summary type="html"><![CDATA[들어가기 전에]]></summary></entry><entry><title type="html">Spring DI와 IoC 컨테이너에 대해서</title><link href="http://localhost:4000/spring/2023/12/01/DI%EC%99%80IOC.html" rel="alternate" type="text/html" title="Spring DI와 IoC 컨테이너에 대해서" /><published>2023-12-01T00:00:00+09:00</published><updated>2023-12-01T00:00:00+09:00</updated><id>http://localhost:4000/spring/2023/12/01/DI%EC%99%80IOC</id><content type="html" xml:base="http://localhost:4000/spring/2023/12/01/DI%EC%99%80IOC.html"><![CDATA[<h1 id="di의존관계-주입--스프링-컨테이너">DI(의존관계 주입) / 스프링 컨테이너</h1>

<p>DI(의존관계 주입)는 애플리케이션 실행 시점에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달하는 과정을 의미합니다. 이를 통해 클라이언트와 서버의 실제 의존관계가 연결됩니다.</p>

<h2 id="ioc-컨테이너-di-컨테이너">IoC 컨테이너, DI 컨테이너</h2>

<p>IoC(Inversion of Control) 컨테이너는 객체의 생성과 관리를 담당합니다. AppConfig와 같은 클래스가 이 역할을 수행합니다.</p>

<h2 id="bean-어노테이션">@Bean 어노테이션</h2>

<p>@Bean 어노테이션은 스프링 컨테이너에 의해 관리될 객체를 선언할 때 사용됩니다. 예를 들어:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">AppConfig</span> <span class="o">{</span>
    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">MemberService</span> <span class="nf">memberService</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MemberService</span><span class="o">(</span><span class="n">memberRepository</span><span class="o">());</span>
    <span class="o">}</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">MemberRepository</span> <span class="nf">memberRepository</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">MemoryMemberRepository</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>ApplicationContext를 사용하여 스프링 컨테이너에 접근하고 빈을 가져올 수 있습니다.</p>

<h2 id="스프링-컨테이너">스프링 컨테이너</h2>

<p>스프링 컨테이너는 ApplicationContext로 표현됩니다. AppConfig와 같은 설정 클래스에서 @Bean으로 등록된 메서드들을 호출하여 객체를 생성하고 관리합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">AnnotationConfigApplicationContext</span><span class="o">(</span><span class="nc">AppConfig</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="nc">MemberService</span> <span class="n">memberService</span> <span class="o">=</span> <span class="n">applicationContext</span><span class="o">.</span><span class="na">getBean</span><span class="o">(</span><span class="s">"memberService"</span><span class="o">,</span> <span class="nc">MemberService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>그럼 왜 IoC와 DI가 졸을까?</p>

<h1 id="iocinversion-of-control와-di의존관계-주입의-장점">IoC(Inversion of Control)와 DI(의존관계 주입)의 장점</h1>

<h2 id="iocinversion-of-control">IoC(Inversion of Control)</h2>

<h3 id="1-코드의-분리-및-관리-용이성">1. 코드의 분리 및 관리 용이성</h3>
<ul>
  <li>IoC는 객체의 생성과 의존성 관리를 외부(컨테이너)에 맡깁니다. 이로 인해 개발자는 객체 간의 연결, 생명주기 관리에 대한 부담 없이 비즈니스 로직에만 집중할 수 있습니다.</li>
</ul>

<h3 id="2-재사용성-및-확장성-향상">2. 재사용성 및 확장성 향상</h3>
<ul>
  <li>IoC를 통해 생성된 객체들은 재사용이 용이하며, 새로운 객체를 추가하거나 변경하는 것이 간편해집니다. 이는 애플리케이션의 확장성을 크게 향상시킵니다.</li>
</ul>

<h3 id="3-테스트-용이성">3. 테스트 용이성</h3>
<ul>
  <li>외부에서 객체를 주입받기 때문에, 테스트 환경에서 모의 객체(Mock)를 사용하는 등의 테스트가 용이해집니다. 이는 유닛 테스트의 효율성을 높여 줍니다.</li>
</ul>

<h2 id="di의존관계-주입">DI(의존관계 주입)</h2>

<h3 id="1-결합도-감소">1. 결합도 감소</h3>
<ul>
  <li>DI를 사용하면 클래스 간의 결합도가 낮아집니다. 클래스가 직접적으로 의존 객체를 생성하지 않고, 외부에서 주입받기 때문에 코드 수정 없이 의존 객체를 교체할 수 있습니다.</li>
</ul>

<h3 id="2-유연한-코드">2. 유연한 코드</h3>
<ul>
  <li>의존성이 외부에서 주입되기 때문에, 상황에 따라 다른 객체를 주입할 수 있어 코드가 더 유연해집니다. 이는 코드의 재사용성을 높이고 유지보수를 용이하게 합니다.</li>
</ul>

<h3 id="3-구성의-중앙화">3. 구성의 중앙화</h3>
<ul>
  <li>의존성이 한 곳(AppConfig와 같은 설정 클래스)에서 관리되므로, 애플리케이션 구성을 쉽게 파악하고 변경할 수 있습니다.</li>
</ul>

<p>IoC와 DI를 사용함으로써, 코드는 더욱 모듈화되고 테스트, 유지보수가 용이해집니다. 또한, 애플리케이션의 확장성과 유연성이 향상되며, 개발자는 비즈니스 로직에 더 집중할 수 있게 됩니다.</p>]]></content><author><name>Ino</name></author><category term="spring" /><category term="java" /><category term="spring" /><summary type="html"><![CDATA[DI(의존관계 주입) / 스프링 컨테이너]]></summary></entry><entry><title type="html">인공신경망과 퍼셉트론</title><link href="http://localhost:4000/ai/2023/04/05/perceptron.html" rel="alternate" type="text/html" title="인공신경망과 퍼셉트론" /><published>2023-04-05T00:00:00+09:00</published><updated>2023-04-05T00:00:00+09:00</updated><id>http://localhost:4000/ai/2023/04/05/perceptron</id><content type="html" xml:base="http://localhost:4000/ai/2023/04/05/perceptron.html"><![CDATA[<h2 id="퍼셉트론과-신경망">퍼셉트론과 신경망</h2>
<hr />

<p>퍼셉트론은 신경망의 기본 구성요소입니다.  <br />
신경망(Neural Net)의 기본 구조를 보면 보통 아래와 같이 그립니다.</p>

<p><img src="https://user-images.githubusercontent.com/95608811/229966707-cea3fd99-1930-406b-b8a8-70a33e52b74f.png" width="800px" />
이 중 파란색으로 동그라미 친 부분, 신경망의 구성요소를 <code class="language-plaintext highlighter-rouge">퍼셉트론</code>이라고 합니다.</p>
<blockquote>
  <p>다른 말로는 Dense(밀집) 혹은 노드(Node) 라고도 부릅니다.</p>
</blockquote>

<h2 id="퍼셉트론의-구성요소">퍼셉트론의 구성요소</h2>
<hr />
<p>위 그림의 신경망에서 하나의 퍼셉트론을 확대해서 보면,</p>

<p><img src="https://user-images.githubusercontent.com/95608811/229966745-2b1c6bbe-0a89-4718-a437-9ce6c2d56d7c.png" width="800px" /></p>

<p>그림과 같이 퍼셉트론은 <code class="language-plaintext highlighter-rouge">입력(inputs)</code>, <code class="language-plaintext highlighter-rouge">가중치(Connection Weight)</code>, <code class="language-plaintext highlighter-rouge">바이어스(bias)</code>, <code class="language-plaintext highlighter-rouge">합 연산(Sum)</code>, <code class="language-plaintext highlighter-rouge">활성 함수(Activation Function)</code>로 구성되어 있습니다. <br />
오느날 인공신경망에서 이용하는 퍼셉트론은 선형 분류기로 이는 입력과 가중치들의 곱을 모두 더한 뒤 활성 함수를 적용해서 그 값이 0보다 크면 1, 0보다 작으면 -1을 출력하는 구조이다.</p>

<p><img src="https://user-images.githubusercontent.com/95608811/176060497-7cb6bb9e-1493-4ac0-8209-48fb38ade3da.png" width="800px" /></p>

<ul>
  <li>그래서 입력을 넣고 입력에 대한 결과를 출력하였을때 원하는 값이 나오도록 가중치를 조절한다.  <br />
<code class="language-plaintext highlighter-rouge">학습</code>이라는게 결국 그 가중치값을 가장 많은 입력에 대해 가장 근접한 <code class="language-plaintext highlighter-rouge">가중치</code>를 찾는 과정이라고 볼 수 있다.</li>
</ul>

<h2 id="신경망으로-풀-수-있는-문제들">신경망으로 풀 수 있는 문제들</h2>
<hr />
<p>활성화 함수, 네트워크 구조 변경을 통해 문제를 풀 수 있습니다. <br />
대표적인 문제로는 <code class="language-plaintext highlighter-rouge">분류(Classification)</code>와 <code class="language-plaintext highlighter-rouge">회귀(Regression)</code>로 나눌 수 있습니다.</p>

<h3 id="분류classification">분류(Classification)</h3>
<p>실생활에서 AI가 적용되는 많은 분야는 분류문제를 해결한 것이 많습니다. <br />
그 예로는 개와 고양이를 분류하는 문제 또는 물체를 Detection 하였을 때, 어떤 물체인 지 분류하는 문제 등  <br />
실생활에서 많은 부분에 사용되고 있습니다.</p>

<p><img src="https://user-images.githubusercontent.com/95608811/229966775-a3bc8443-2914-4fab-87a6-bc04c0f34589.png" width="800px" /></p>

<p>위 사진과 같이 분류해야 하는 <code class="language-plaintext highlighter-rouge">class의 갯수</code> 만큼 <code class="language-plaintext highlighter-rouge">Output layer</code>의 퍼셉트론 개수가 정해지게 된다.</p>

<h3 id="회귀regression">회귀(Regression)</h3>
<p>분류를 제외한 다른 문제는 회귀(Regression)문제에 해당합니다.  <br />
공부한 시간(x)을 가지고 합격확률(y)를 예측하거나, 키(x)를 가지고 몸무게(y)를 예측하는 등 분류하는 것이 아니라 확률 또는 값과 같은 숫자를 맞추는 문제라고 생각하면 됩니다.</p>

<p><img src="https://user-images.githubusercontent.com/95608811/229966792-2ed7e419-001b-47a1-8ace-602987da7dbc.png" width="800px" /></p>

<p>위와 같은 간단한 예시에서는 보통 Output layer의 퍼셉트론 개수를 하나로 두는 경우가 많습니다.  <br />
이런 문제에 대해서 마지막 퍼셉트론의 활성화 함수를 정할 때, 활성함수를 문제에 맞게끔 설정해야 합니다. <br />
0~1 사이의 확률을 가리키는 문제에서는 시그모이어함수, 다채로운 값을 가질 수 있을땐 ReLU 등  <br />
활성함수에 대해서는 다음 포스팅에서 다루겠습니다.</p>]]></content><author><name>Ino</name></author><category term="ai" /><category term="ai" /><summary type="html"><![CDATA[퍼셉트론과 신경망]]></summary></entry><entry><title type="html">SOLID - 객체 지향 설계의 5가지 원칙</title><link href="http://localhost:4000/spring,/java/2022/10/10/SOLID.html" rel="alternate" type="text/html" title="SOLID - 객체 지향 설계의 5가지 원칙" /><published>2022-10-10T00:00:00+09:00</published><updated>2022-10-10T00:00:00+09:00</updated><id>http://localhost:4000/spring,/java/2022/10/10/SOLID</id><content type="html" xml:base="http://localhost:4000/spring,/java/2022/10/10/SOLID.html"><![CDATA[<h1 id="solid">SOLID</h1>
<h3 id="클린코드로-유명한-로버트-마틴의-객체-지향-설계의-5가지-원칙">클린코드로 유명한 로버트 마틴의 객체 지향 설계의 5가지 원칙</h3>

<p>SOLID란 객체 지향 프로그래밍을 하면서 지켜야하는 5대 원칙으로 각각 SRP(단일 책임 원칙), OCP(개방-폐쇄 원칙), LSP(리스코프 치환 원칙), DIP(의존 역전 원칙), ISP(인터페이스 분리 원칙)의 앞글자를 따서 만들어졌다. SOLID 원칙을 철저히 지키면 시간이 지나도 변경이 용이하고, 유지보수와 확장이 쉬운 소프트웨어를 개발하는데 도움이 되는 것으로 알려져있다.</p>

<h3 id="srp--단일-책임-원칙-single-responsibility-principle">SRP : 단일 책임 원칙 (single responsibility principle)</h3>

<ul>
  <li>한 클래스는 하나의 책임만 가져야 한다.</li>
  <li>하나의 책임이라는 것은 모호하다 ( 문맥과 상황에 따라 다르다. )</li>
  <li>중요한 기준은 변경이다. 변경이 있을 때 파급효과가 적으면 단일 책임 원칙을 잘 따른 것
    <blockquote>
      <p>ex) 객체 생성과 사용을 분리, 디스플레이에 띄우는 부분과 핵심로직은 분리</p>
    </blockquote>
  </li>
</ul>

<h3 id="ocp--개방-폐쇄-원칙-openclosed-principle">OCP : 개방-폐쇄 원칙 (Open/Closed principle)</h3>

<ul>
  <li>소프트웨어 요소는 확장에는 열려있으나, 변경에는 닫혀있어야한다.</li>
  <li>확장에 대해 열려 있다: 요구사항이 변경될 때 새로운 동작을 추가하여 애플리케이션의 기능을 확장할 수 있다.</li>
  <li>
    <p>수정에 대해 닫혀 있다: 기존의 코드를 수정하지 않고 애플리케이션의 동작을 추가하거나 변경할 수 있다.</p>
  </li>
  <li>
    <p>개방 폐쇄 원칙을 지키기 위해서는 추상화에 의존해야 한다. 추상화란 핵심적인 부분만 남기고, 불필요한 부분은 제거함으로써 복잡한 것을 간단히 하는 것이고, 추상화를 통해 변하지 않는 부분만 남김으로써 기능을 구체화하고 확장할 수 있다. 변하지 않는 부분은 고정하고 변하는 부분을 생략하여 추상화함으로써 변경이 필요한 경우에 생략된 부분을 수정하여 개방-폐쇄의 원칙을 지킬 수 있다.</p>
  </li>
  <li>다형성을 위한 추상화를 활용해서 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현한다.</li>
</ul>

<h3 id="lsp--리스코프-치환-원칙-liskov-substitution-principle">LSP : 리스코프 치환 원칙 (Liskov substitution principle)</h3>
<ul>
  <li>프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인터페이스로 바꿀 수 있어야 한다.</li>
  <li>다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체를 믿고 사용하려면, 이 원칙이 필요하다.</li>
  <li>단순히 컴파일에 성공하는 것을 넘어서는 이야기로 상식적으로 해당 객체의 생성 목적대로 사용하면 된다.</li>
</ul>

<h3 id="isp--인터페이스-분리-원칙-interface-segregation-principle">ISP : 인터페이스 분리 원칙 (Interface segregation principle)</h3>
<ul>
  <li>특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.</li>
  <li>자동차 인터페이스 -&gt; 운전 인터페이스, 정비 인터페이스로 분리</li>
  <li>사용자 클라이언트 -&gt; 운전자 클라이언트, 정비사 클라이언트로 분리</li>
  <li>분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음</li>
  <li>인터페이스가 명확해지고, 대체 가능성이 높아진다.</li>
</ul>

<h3 id="dip--의존관계-역전-원칙-dependency-inversion-principle">DIP : 의존관계 역전 원칙 (Dependency inversion principle)</h3>
<ul>
  <li>프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.” 의존성 주입은 이 원칙을 따르는 방법 중 하나이다.</li>
  <li>쉽게 말해서 구현 클래스에 의존하지말고, 인터페이스에 의존하라는 뜻이다.</li>
  <li>앞에서 이야기한 역할(Role)에 의존하게 해야 한다는 것과 같다.  <br />
객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다.  <br />
구현체에 의존하게 되면 수정이 어려워지게 된다.</li>
</ul>

<h2 id="정리하자면">정리하자면,</h2>
<p>객체지향의 핵심은 다형성인데, 다형성 만으로는 OCP랑 DIP를 지킬 수가 없다.</p>

<p>끝.</p>

<h2 id="이-아니라-스프링은-didependency-injection으로-다형성--ocp-dip를-가능하게-지원한다">이 아니라 스프링은 DI(Dependency Injection)으로 다형성 + OCP, DIP를 가능하게 지원한다.</h2>

<p>그래서, 스프링을 쓰자.</p>]]></content><author><name>Ino</name></author><category term="spring," /><category term="java" /><category term="java" /><category term="spring" /><summary type="html"><![CDATA[SOLID 클린코드로 유명한 로버트 마틴의 객체 지향 설계의 5가지 원칙]]></summary></entry><entry><title type="html">JAVA Spring 시작하기</title><link href="http://localhost:4000/spring/2022/09/20/sprig%EC%8B%9C%EC%9E%91.html" rel="alternate" type="text/html" title="JAVA Spring 시작하기" /><published>2022-09-20T00:00:00+09:00</published><updated>2022-09-20T00:00:00+09:00</updated><id>http://localhost:4000/spring/2022/09/20/sprig%EC%8B%9C%EC%9E%91</id><content type="html" xml:base="http://localhost:4000/spring/2022/09/20/sprig%EC%8B%9C%EC%9E%91.html"><![CDATA[<h2 id="spring-라이브러리">Spring 라이브러리</h2>

<h3 id="spring-boot-library">Spring Boot Library</h3>
<ul>
  <li>spring-boot-starter-web</li>
  <li>
    <ul>
      <li>spring-boot-starter-tomcat : 톰캣(웹서버)</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>spring-webmvc : 스프링 웹 MVC</li>
    </ul>
  </li>
  <li>spring-boot-starter-thymeleaf : 타입리프 템플릿 엔진(View)</li>
  <li>spring-boot-starter(공통) : 스프링부트 + 스프링코어 + 로깅</li>
  <li>
    <ul>
      <li>spring-boot</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>
        <ul>
          <li>spring-core</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <ul>
      <li>spring-boot-starter-logging</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>
        <ul>
          <li>logback, slf4j</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="test-library">Test Library</h3>
<ul>
  <li>junit : 테스트 프레임워크</li>
  <li>mockito : 목라이브러리</li>
  <li>assertj : 테스트코드를 좀 더 편하게 작성하게 도와주는 라이브러리</li>
  <li>spring-test : 스프링 통합 테스트 지원</li>
</ul>

<h2 id="controller">Controller</h2>

<p><code class="language-plaintext highlighter-rouge">src/main/java/packageName/HelloController.java</code> 에서 아래처럼 코딩후</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">HelloController</span> <span class="o">{</span>
    <span class="nd">@GetMapping</span><span class="o">(</span><span class="s">"hello"</span><span class="o">)</span>
    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">hello</span><span class="o">(</span><span class="nc">Model</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"data"</span><span class="o">,</span><span class="s">"hello!!"</span><span class="o">);</span>
        <span class="k">return</span> <span class="s">"hello"</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">resources/templates</code> 에서 <code class="language-plaintext highlighter-rouge">hello.html</code> 을 만든후</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">xmlns:th=</span><span class="s">"http://www.thymeleaf.org"</span><span class="nt">&gt;</span>
<span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">charset=</span><span class="s">"UTF-8"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">http-equiv=</span><span class="s">"X-UA-Compatible"</span> <span class="na">content=</span><span class="s">"IE=edge"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">name=</span><span class="s">"viewport"</span> <span class="na">content=</span><span class="s">"width=device-width, initial-scale=1.0"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;title&gt;</span>Document<span class="nt">&lt;/title&gt;</span>
<span class="nt">&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span>
<span class="nt">&lt;p</span> <span class="na">th:text=</span><span class="s">"'안녕하세요.'  + ${data}"</span><span class="nt">&gt;</span>안녕하세요 고객님 <span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>
<p>위와같이 입력하면, <code class="language-plaintext highlighter-rouge">${data}</code> 위치에 <code class="language-plaintext highlighter-rouge">hello!!</code> 가 치환되어서 들어가게된다. <br />
이는,   <br />
<code class="language-plaintext highlighter-rouge">thymeleaf</code> 템플릿엔진에서 WebBrower 가 local:8080/hello 를 spring boot 에 있는 내장 Tomcat server에 보내고 Tomcat server가  스프링컨테이너에서 hello Controller의 return이 문자(hello) 로 반환되어 있어 View Resolver가 화면을 찾아서 처리해준 결과이다. <br />
나는 <code class="language-plaintext highlighter-rouge">thymeleaf</code> 템플릿엔진이 addAttribute 의 첫번재 인자를 두번째 인자로 데이터바인딩 해주었다고 이해하고 넘어갔다.</p>

<h2 id="빌드하고-실행하기">빌드하고 실행하기</h2>
<p>쉘에서 해당 폴더에 들어간 후 <code class="language-plaintext highlighter-rouge">./gradlew build </code> 를 통해 바로 실행시켜준다.  <br />
그럼 <code class="language-plaintext highlighter-rouge">build</code> 디렉토리가 생긴다. <br />
<code class="language-plaintext highlighter-rouge">build</code>디렉토리에 있는 <code class="language-plaintext highlighter-rouge">libs</code>에 들어가서 <code class="language-plaintext highlighter-rouge">java -jar hello-0.0.1-SNAPSHOT.jar</code> 로 .jar 파일을 바로 실행할 수 있다.
<code class="language-plaintext highlighter-rouge">.jar</code> 파일을 실행하면 Eclipse 또는 intellij 내에서 Run을 시키지 않아도 바로 서버를 구동시킬 수 있다.</p>]]></content><author><name>Ino</name></author><category term="spring" /><category term="java" /><category term="spring" /><summary type="html"><![CDATA[Spring 라이브러리]]></summary></entry><entry><title type="html">C언어 Makefile 이해하기</title><link href="http://localhost:4000/c/2022/09/19/Makefile.html" rel="alternate" type="text/html" title="C언어 Makefile 이해하기" /><published>2022-09-19T00:00:00+09:00</published><updated>2022-09-19T00:00:00+09:00</updated><id>http://localhost:4000/c/2022/09/19/Makefile</id><content type="html" xml:base="http://localhost:4000/c/2022/09/19/Makefile.html"><![CDATA[<h2 id="makefile-왜-쓰는데">Makefile 왜 쓰는데?</h2>
<p>간단한 소스코드 파일 한두개라면 몰라도 컴파일 해야할 코드 갯수가 굉장히 많아지면 gcc 방식으로 하나하나 컴파일 하는것은 시간도 오래걸리고 굉장히 귀찮은 일이된다.  <br />
그래서 반복적인 작업을 피하기 위해서 쓰는것이 make 유틸리티이다.</p>

<h2 id="make--makefile">make / Makefile</h2>
<p>make는 유틸리티 이름이다. <br />
make 유틸리티는 Makefile이라는 파일의 내용을 읽어서 목표 파일(target)을 만듭니다.</p>

<h2 id="컴파일과정">컴파일과정</h2>
<ol>
  <li>c파일에서 object 파일 생성하기 <br />
ex) <code class="language-plaintext highlighter-rouge">gcc -c -o ft_strlen.o ft_strlen.c</code>
    <ul>
      <li>-c 옵션은 해당 c파일을 .o(오브젝트)파일로 만들어준다.</li>
      <li>-o 옵션은 생성될 파일의 이름을 지정해준다.
        <blockquote>
          <p>지금처럼 -c 옵션을 쓸 때는 -o 옵션으로 output name을 지정해주지 않아도 자동으로 .c의 이름의 .o 파일로
만들어진다.
하지만  실행 파일 생성시 -o 옵션을 넣지 않으면 모든 파일이 a.out 이라는 이름을 가지게 되므로 여러 개의 실행 파일을 생성해야 할 때 -o 옵션을 넣어서 이름을 명시적으로 붙여주는 것이 좋다.</p>
        </blockquote>
      </li>
    </ul>
  </li>
  <li>
    <p>각 object파일을 link해서 컴파일을 통해 exe 실행파일 생성하기 <br />
<code class="language-plaintext highlighter-rouge">gcc -o strlen.exe main.o ft_strlen.o</code>  <br />
Object 파일의 순서들은 상관이 없고 해당 내용처럼 써주면 main.o 와 ft_strlen을 링크해서 strlen.exe 를 생성한다.</p>
  </li>
  <li>실행하기 <br />
<code class="language-plaintext highlighter-rouge">./strlen.exe</code> 이런식으로 실행을 하면 해당 파일이 실행된다. <br />
추가로, main 에 argc, argv[] 인자를 실행시 넣고 싶으면, <code class="language-plaintext highlighter-rouge">./strlen.exe [argv[0]][argv[1]]</code>
```c
// 2022.09.20 편집중//</li>
</ol>]]></content><author><name>Ino</name></author><category term="c" /><category term="c" /><summary type="html"><![CDATA[Makefile 왜 쓰는데? 간단한 소스코드 파일 한두개라면 몰라도 컴파일 해야할 코드 갯수가 굉장히 많아지면 gcc 방식으로 하나하나 컴파일 하는것은 시간도 오래걸리고 굉장히 귀찮은 일이된다. 그래서 반복적인 작업을 피하기 위해서 쓰는것이 make 유틸리티이다.]]></summary></entry><entry><title type="html">C언어 write 함수</title><link href="http://localhost:4000/c/2022/09/18/%ED%99%98%EA%B2%BD%EB%B3%80%EC%88%98%EC%99%80-id.html" rel="alternate" type="text/html" title="C언어 write 함수" /><published>2022-09-18T00:00:00+09:00</published><updated>2022-09-18T00:00:00+09:00</updated><id>http://localhost:4000/c/2022/09/18/%ED%99%98%EA%B2%BD%EB%B3%80%EC%88%98%EC%99%80%20id</id><content type="html" xml:base="http://localhost:4000/c/2022/09/18/%ED%99%98%EA%B2%BD%EB%B3%80%EC%88%98%EC%99%80-id.html"><![CDATA[<h2 id="unistdh-가-뭔데">unistd.h 가 뭔데?</h2>
<p>POSIX 운영체제 API에 대한 엑세스를 제공하는 헤더파일이다.   <br />
보통 Unix 에 쓰이는 표준 심볼들과 상수들을 정의해 놓은 것이기 때문에 unistd.h에 포함되어 있는 내용은 대부분 유닉스환경에서만 쓸 수 있다.</p>

<h2 id="write-함수를-어디에-쓰는건데">write 함수를 어디에 쓰는건데?</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="kt">ssize_t</span> <span class="nf">write</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">nbytes</span><span class="p">);</span>
</code></pre></div></div>

<p>보통 오픈한 파일에 데이터를 쓸 때 사용하는 함수이다.  <br />
return value : 성공 시 기록된 바이트수, 에러시 -1을 return 한다.</p>

<p>그런데,해당 함수를 <stdio.h> 에 있는 printf() 대용으로 사용하는 경우도 있는데 이런경우 어떤식으로 사용하는지에 대해 간단하게 설명하고자 한다.</stdio.h></p>

<p>일단 함수를 사용하면 파라미터에 어떤 value를 넣는지에 대해 알아야한다.</p>
<ul>
  <li>해당 포스트는 write함수를 모니터에 버퍼출력용으로 사용하는 방법에 대해 알아보는 것이기 때문에,
일반적으올 사용하는 방법 및 개념과는 많이 다를 수 있음</li>
</ul>

<h2 id="첫번째-파라미터-파일디스크립터">첫번째 파라미터 파일디스크립터</h2>
<p>파일 디스크립터(File Descriptor)란 리눅스 혹은 유닉스 계열의 시스템에서 프로세스(process)가 파일(file)을 다룰 때 사용하는 개념으로, 프로세스에서 특정 파일에 접근할 때 사용하는 추상적인 값이다. 파일 디스크럽터는 일반적으로 0이 아닌 정수값을 갖는다.</p>

<p>흔히 유닉스 시스템에서 모든 것을 파일이라고 한다. <br />
유닉스 시스템에서 프로세스가 이 파일들을 접근할 때 파일 디스크립터라는 개념을 이용한다. 프로세스가 열려있는 파일에 시스템 콜을 이용해서 접근할 때, 파일 디스크립터(FD)값을 이용해서 파일을 지칭할 수 있다.</p>

<p>프로그램이 프로세스로 메모리에서 실행될 때, 기본적으로 할당되는 파일디스크립터는 표준입력(Standard Input), 표준 출력(Standard Output), 표준에러(Standard Error)이며 이들에게 각각 0, 1, 2라는 정수가 할당된다.</p>

<p>즉, 첫번째 파라미터인 int fd에는 0,1,2의 값이 들어갈 수 있다.</p>

<p>그 중에 우리는 표준출력만을 사용하므로 printf 대용으로 일반적인 값을 출력할 떈 1 로 고정해서 써도 무방하다.</p>

<h2 id="두번째-파라미터-버퍼">두번째 파라미터 버퍼</h2>
<p>출력할 내용을 적으면 된다.
유의해야할 점은 버퍼가 char 형태로 받아지기 때문에 int형을 write 하고싶다면, itoa 등의 함수를 사용하거나 아스키값을 char 형태만큼 적당히(?) 조절해서 써줘야한다.</p>

<h2 id="세번째-파라미터-nbytes">세번째 파라미터 nbytes</h2>
<p>그냥 출력해야 할 버퍼가 몇 바이트인지 맞춰서 쓰면 된다.</p>

<h2 id="종합하자면">종합하자면,</h2>
<h3 id="buf로부터-filedes로-nbytes만큼의-데이터를-쓴다">buf로부터 filedes로 nbytes만큼의 데이터를 쓴다.</h3>

<p>Hello World 를 출력하고싶다면,</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"Hello World"</span><span class="p">,</span> <span class="mi">11</span><span class="p">);</span>

<span class="kt">char</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
<span class="n">a</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Hello World"</span><span class="p">;</span>
<span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="mi">12</span><span class="p">);</span>
</code></pre></div></div>

<p>이런식으로 출력을 원하는 리터럴문자를 직접 큰따옴표로 묶어서 넣어주거나, 변수의 주소값을 넣어주면 출력가능하다.</p>

<p>int 형태는 char 형태로 출력가능하다고 했었는데,</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"0123456789"</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</code></pre></div></div>
<p>이런식의 출력은 결국 숫자가 들어간 문자열이기 때문에 출력가능하다.</p>]]></content><author><name>Ino</name></author><category term="c" /><category term="c" /><summary type="html"><![CDATA[unistd.h 가 뭔데? POSIX 운영체제 API에 대한 엑세스를 제공하는 헤더파일이다. 보통 Unix 에 쓰이는 표준 심볼들과 상수들을 정의해 놓은 것이기 때문에 unistd.h에 포함되어 있는 내용은 대부분 유닉스환경에서만 쓸 수 있다.]]></summary></entry></feed>