<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-06-12T17:05:03+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">시를 좋아하는 프로그래머</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>AlphateamInho</name></author><entry><title type="html">SQL기본문법</title><link href="http://localhost:4000/db/2022/06/12/SQL%EA%B8%B0%EB%B3%B8%EB%AC%B8%EB%B2%95.html" rel="alternate" type="text/html" title="SQL기본문법" /><published>2022-06-12T00:00:00+09:00</published><updated>2022-06-12T00:00:00+09:00</updated><id>http://localhost:4000/db/2022/06/12/SQL%EA%B8%B0%EB%B3%B8%EB%AC%B8%EB%B2%95</id><content type="html" xml:base="http://localhost:4000/db/2022/06/12/SQL%EA%B8%B0%EB%B3%B8%EB%AC%B8%EB%B2%95.html"><![CDATA[<h2 id="select-기능">SELECT 기능</h2>

<ul>
  <li>내가 원하는 정보 가져오기</li>
</ul>

<p>1) 테이블 전체 정보 보기</p>
<pre><code class="language-SQL">SELECT * FROM Customers;
</code></pre>

<blockquote>
  <p>*(asterisk)는 테이블의 모든 컬럼을 뜻한다.</p>
</blockquote>

<hr />

<p>2) 원하는 컬럼만 보기</p>
<pre><code class="language-SQL">SELECT CustomerName FROM Customers;
</code></pre>
<pre><code class="language-SQL">SELECT CustomerName, ContactName, Country
FROM Customers;
</code></pre>

<hr />

<p>3) 원하는 조건의 row(행)만 걸러서 보기</p>

<ul>
  <li>WHERE 구문 뒤에 조건을 붙여 원하는 데이터만 가져올 수 있습니다.</li>
</ul>

<pre><code class="language-SQL">SELECT * FROM Orders
WHERE EmployeeID = 3;
</code></pre>

<pre><code class="language-SQL">SELECT * FROM OrderDetails
WHERE Quantity &lt; 5;
</code></pre>

<hr />

<p>4) 원하는 순서로 데이터 가져오기</p>

<ul>
  <li>ORDER BY 구문을 사용해서 특정 컬럼을 기준으로 데이터를 정렬할 수 있습니다.</li>
</ul>

<pre><code class="language-SQL">구문	 기준	  기본    
ASC	오름차순  [x]
DESC	내림차순 []
</code></pre>

<pre><code class="language-SQL">SELECT * FROM Customers
ORDER BY ContactName;
</code></pre>

<pre><code class="language-SQL">SELECT * FROM OrderDetails
ORDER BY ProductID ASC, Quantity DESC;
</code></pre>
<hr />

<h2 id="sql-기본연산자">SQL 기본연산자</h2>

<pre><code class="language-SQL">연산자	의미
AND, &amp;&amp;	양쪽이 모두 TRUE일 때만 TRUE
OR, ||	한쪽은 TRUE면 TRUE
</code></pre>

<pre><code class="language-SQL">SELECT * FROM Orders
WHERE
  CustomerId = 15 AND EmployeeId = 4;
</code></pre>

<pre><code class="language-OPERATOR">연산자	의미
=	양쪽 값이 같음
!=, &lt;&gt;	양쪽 값이 다름
&gt;, &lt;	(왼쪽, 오른쪽) 값이 더 큼
&gt;=, &lt;=	(왼쪽, 오른쪽) 값이 같거나 더 큼
</code></pre>

<pre><code class="language-BETWEEN">연산자	의미
BETWEEN {MIN} AND {MAX}	두 값 사이에 있음
NOT BETWEEN {MIN} AND {MAX}	두 값 사이가 아닌 곳에 있음
</code></pre>

<h3 id="총정리">총정리</h3>

<pre><code class="language-GRAMMER">연산자	의미
+, -, *, /	각각 더하기, 빼기, 곱하기, 나누기
%, MOD	나머지
IS	양쪽이 모두 TRUE 또는 FALSE
IS NOT	한쪽은 TRUE, 한쪽은 FALSE
AND, &amp;&amp;	양쪽이 모두 TRUE일 때만 TRUE
OR, ||	한쪽은 TRUE면 TRUE
=	양쪽 값이 같음
!=, &lt;&gt;	양쪽 값이 다름
&gt;, &lt;	(왼쪽, 오른쪽) 값이 더 큼
&gt;=, &lt;=	(왼쪽, 오른쪽) 값이 같거나 더 큼
BETWEEN {MIN} AND {MAX}	두 값 사이에 있음
NOT BETWEEN {MIN} AND {MAX}	두 값 사이가 아닌 곳에 있음
IN (...)	괄호 안의 값들 가운데 있음
NOT IN (...)	괄호 안의 값들 가운데 없음
LIKE '... % ...'	0~N개 문자를 가진 패턴
LIKE '... _ ...'	_ 갯수만큼의 문자를 가진 패턴
</code></pre>]]></content><author><name>Ino</name></author><category term="DB" /><category term="DB" /><category term="SQL" /><summary type="html"><![CDATA[SELECT 기능]]></summary></entry><entry><title type="html">SQL문제</title><link href="http://localhost:4000/db/2022/06/12/SQL%EB%AC%B8%EC%A0%9C.html" rel="alternate" type="text/html" title="SQL문제" /><published>2022-06-12T00:00:00+09:00</published><updated>2022-06-12T00:00:00+09:00</updated><id>http://localhost:4000/db/2022/06/12/SQL%EB%AC%B8%EC%A0%9C</id><content type="html" xml:base="http://localhost:4000/db/2022/06/12/SQL%EB%AC%B8%EC%A0%9C.html"><![CDATA[<h2 id="sql-문제">SQL 문제</h2>

<p><img src="https://user-images.githubusercontent.com/95608811/173223493-4b33e677-66ff-4ae8-9cd1-cf306f69909f.png" width="600px" /></p>

<p>```SQL</p>]]></content><author><name>Ino</name></author><category term="DB" /><category term="DB" /><category term="SQL" /><summary type="html"><![CDATA[SQL 문제]]></summary></entry><entry><title type="html">DB 정규화</title><link href="http://localhost:4000/db/2022/06/11/DB%EC%A0%95%EA%B7%9C%ED%99%94.html" rel="alternate" type="text/html" title="DB 정규화" /><published>2022-06-11T00:00:00+09:00</published><updated>2022-06-11T00:00:00+09:00</updated><id>http://localhost:4000/db/2022/06/11/DB%EC%A0%95%EA%B7%9C%ED%99%94</id><content type="html" xml:base="http://localhost:4000/db/2022/06/11/DB%EC%A0%95%EA%B7%9C%ED%99%94.html"><![CDATA[<h2 id="정규화-">정규화 ?</h2>

<ul>
  <li>
    <p>DB시스템을 만지다보면 엄청나게 많은 테이블들이 얽혀있어 하나의 데이터를 수정했을때 여러문제가 생길 수 있는데,
정규화를 통해서 정해진 규칙대로 테이블을 쪼개게 되면, 문제점들을 사전에 해소할 수 있음.</p>
  </li>
  <li>
    <p>가장 대표적인 문제점들로는 삭제이상(delete), 삽입이상(insert), 수정이상(update)</p>
  </li>
  <li>삭제이상은 지정된 테이블에서 데이터를 삭제하려고 하는데, 연결된 다른테이블에서도 데이터가 삭제되는 것이다.</li>
  <li>삽입이상은 지정된 테이블에 데이터를 삽입하려고 하는데, 연결된 다른테이블에서도 데이터가 삽입되는 것이다.</li>
  <li>수정이상은 원하는 데이터를 모두 수정하지 못하고, 일부 데이터만 수정되는 것이다.</li>
</ul>

<p>이러한 문제점들을 해소하기 위해서 테이블을 쪼개는 것이다.</p>

<h2 id="제1정규화">제1정규화</h2>

<ol>
  <li>어떤 Relation에 속한 모든 Domain이 원자값만으로 되어 있다.</li>
  <li>모든 attribute에 반복되는 그룹이 나타나지 않는다</li>
  <li>기본키를 사용하여 관련 데이터의 각 집합을 고유하게 식별할 수 있어야한다.</li>
</ol>

<blockquote>
  <p>릴레이션 = 테이블 = 앤티티 = 개체   <br />
행 = row = 레코드 = 투플  <br />
열 = 컬럼 = 필드 = 속성 = 어트리뷰트  <br />
원자값 (atomic value) : 더 이상 쪼갤 수 없는 값</p>
</blockquote>

<ul>
  <li>
    <p>1번은 그냥 한개의 릴레이션에 여러개의 값이 들어가면 안된다는 것이다.  <br />
ex ) 취미 : 등산, 골프  » 이러면 안된다는 것이다.</p>
  </li>
  <li>
    <p>2번은 위와같이 한개의 Relation에 여러개의 값이 들어가는 것을 막기위해 같은 그룹을 여러 개 만드는것이다.
ex ) 취미1 : 등산, 취미2 : 골프 » 이러면 1번을 안하려고 억지로 릴레이션을 분리하는것이니깐 정규화 하는 의미가 없다.</p>
  </li>
  <li>
    <p>3번은 1번,2번 case를 막기위해 <br />
내취미 : 등산, 내취미 : 골프  <br />
이런식으로 같은 릴레이션을 만들어 관련 데이터를 고유하게 식별하지 못하게 하면 안된다는 것이다.</p>
  </li>
  <li>사실 그냥 반복그룹을 제거하되 그괴정에서 의미가 없는 방식으로 제거하지 말라는 것이다.</li>
  <li>왜 정규화 하는지를 생각하면 제1정규화는 <code class="language-plaintext highlighter-rouge">반복그룹제거</code> 하나로 방식을 통일할 수 있다.</li>
</ul>

<h2 id="제2정규화">제2정규화</h2>

<ul>
  <li>제2 정규화를 수행 했을 경우 테이블의 모든 컬럼이 완전 함수적 종속을 만족한다.
    <blockquote>
      <p>부분 함수적 종속을 모두 제거했다는 뜻이다.</p>
    </blockquote>
  </li>
</ul>

<blockquote>
  <p>함수적 종속 : x값에 따라 y값이 결정될 때 x-&gt;y로 표현하는데, 이를 y는 x에 대해 수적 종속이라고 한다. <br />
예를들어 학번을 알면 이름을 알 수 있는데, 이 경우엔 학번이 x가 되고 이름이 y가 된다.  <br />
x를 결정자라고 하고, y를 종속자라고 한다. <br />
즉 다시말해서, x가 바뀌었을 경우 y가 바뀌어야만 한다는 것이다.</p>
</blockquote>

<blockquote>
  <p>함수적 종속에서 x의 값이 여러 요소일 경우, 즉 {x1,x2} -&gt; y 일 경우, x1과 x2가 y의 값을 결정할 때 이를 완전 함수적 종속이라고 하고, x1,x2 중 하나만 y의 값을 결정할 때 이를 부분 함수적 종속이라고 한다.</p>
</blockquote>

<p><img src="https://user-images.githubusercontent.com/95608811/173193344-e11fe49c-6039-43c6-804a-605df896c729.png" width="600px" /></p>

<p>위에서 model과 manufacture을 알면 model full name 필드를 아예 유지하지 않거나 참조하지 않아도 결정되기 때문에 {model,manufactor} -&gt; model full name 이라고 할 수 있다. 하지만, {model, manufactor} -&gt; manufactor country 에서 model과 manufacturer country는 아무런 연관 관계가 없기 때문에, manufacturer country는 manufacturer와만 종속관계에 있게 되고 이를 부분 함수 종속이라고 하게 되는 것이다.  아래의 그림을 보면 쉽게 이해할 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/95608811/173193358-c3119a2b-09ed-4103-97ec-d524f01144ff.png" width="600px" /></p>

<p>위에서 부분 함수 종속을 제거 하게 되면, 아래와 같은 그림이 된다.</p>

<p><img src="https://user-images.githubusercontent.com/95608811/173193379-dcafdf0f-6840-4e8a-8c58-ed4ca6d7fb87.png" width="600px" /></p>

<p>따라서, 부분 함수 종속을 제거한 이후의 테이블은 아래와 같고, 이는 제 2정규형을 만족한 테이블이다.</p>

<p><img src="https://user-images.githubusercontent.com/95608811/173193384-176d99b9-7694-4be3-b8c4-1572b50641b3.png" width="600px" /></p>

<ul>
  <li>왜 정규화 하는지를 생각하면 제2정규화는 <code class="language-plaintext highlighter-rouge">부분함수적종속성제거</code> 하나로 방식을 통일할 수 있다.</li>
</ul>

<h2 id="제3정규화">제3정규화</h2>

<ul>
  <li>테이블(Relation)이 제 3정규형을 만족한다는 것은 아래 두 가지 조건을 만족하는 것을 의미한다.
    <ol>
      <li>Relation이 제 2정규화 되었다.(The relation is in second normal form)</li>
    </ol>
  </li>
</ul>

<ol>
  <li>기본 키(primary key)가 아닌 속성(Attribute)들은 기본 키에만 의존해야 한다.</li>
</ol>

<p><img src="https://user-images.githubusercontent.com/95608811/173193429-150e49b7-397e-486b-8e8e-9113c7d266e1.png" width="600px" /></p>

<p>위 테이블에서 {Tournament, Year}가 후보키가 된다. 하지만 Winner Date of Birth은 기본키가 아닌 속성인 Winner를 거쳐 {Tournament, Year}에 의존하고 있는 것을 알 수 있는데, 이는 3NF를 위반한 것이 된다. 따라서 테이블을 아래와 같이 둘로 나누어 주자</p>

<p><img src="https://user-images.githubusercontent.com/95608811/173193437-2e3d5c51-f6cf-4a07-97cd-c4e688a04eba.png" width="600px" /></p>

<p>위 테이블은 3정규화를 만족한 상태이다.</p>

<ul>
  <li>왜 정규화 하는지를 생각하면 제3정규화는 <code class="language-plaintext highlighter-rouge">이행적종속성</code> 하나로 방식을 통일할 수 있다.</li>
</ul>]]></content><author><name>Ino</name></author><category term="DB" /><category term="DB" /><category term="SQL" /><summary type="html"><![CDATA[정규화 ?]]></summary></entry><entry><title type="html">문서편집기 vi</title><link href="http://localhost:4000/system/2022/06/09/%EB%AC%B8%EC%84%9C%ED%8E%B8%EC%A7%91%EA%B8%B0vi.html" rel="alternate" type="text/html" title="문서편집기 vi" /><published>2022-06-09T00:00:00+09:00</published><updated>2022-06-09T00:00:00+09:00</updated><id>http://localhost:4000/system/2022/06/09/%EB%AC%B8%EC%84%9C%ED%8E%B8%EC%A7%91%EA%B8%B0vi</id><content type="html" xml:base="http://localhost:4000/system/2022/06/09/%EB%AC%B8%EC%84%9C%ED%8E%B8%EC%A7%91%EA%B8%B0vi.html"><![CDATA[<h2 id="vi-편집기">vi 편집기</h2>
<blockquote>
  <p>vi 편집기는 일반적으로 모드가 나누어져 있기 때문에, 따로 공부를 하지 않으면 사용할 때 어려움이 있다.</p>
</blockquote>

<ul>
  <li>명령모드 : 모드변경,복사,이동등의 작업</li>
  <li>편집모드 : 문서작성 및 편집</li>
  <li>
    <p>Last Line 모드 : 치환, 저장 및 종료 수행</p>
  </li>
  <li>명령모드에서 <code class="language-plaintext highlighter-rouge">i</code>,<code class="language-plaintext highlighter-rouge">o</code>,<code class="language-plaintext highlighter-rouge">a</code> 를 입력하면 편집모드로 이동된다
    <blockquote>
      <p>i 는 커서의 앞부분 부터, a 는 커서의 다음부분 부터, o를 입력하면 커서의 아래라인부터 입력이 된다</p>
    </blockquote>
  </li>
  <li>명령모드에서 <code class="language-plaintext highlighter-rouge">:</code>를 입력하면 <code class="language-plaintext highlighter-rouge">Last Line 모드</code>로 넘어가게 된다</li>
  <li><code class="language-plaintext highlighter-rouge">Last Line 모드</code>에서 <code class="language-plaintext highlighter-rouge">:wq</code> 등의 명령어로 모드에서 나올 수 있다
    <blockquote>
      <p><code class="language-plaintext highlighter-rouge">:wq</code> 는 저장하고 나가기</p>
    </blockquote>
  </li>
</ul>

<h3 id="command-모드--가장-기본이-되는-모드-복사-붙여넣기-다른-모드로-전환-커서-이동-삭제-등">Command 모드 : 가장 기본이 되는 모드, 복사, 붙여넣기, 다른 모드로 전환, 커서 이동, 삭제 등</h3>

<p>(1) 커서 이동
<code class="language-plaintext highlighter-rouge">G</code> : 가장 마지막 줄로 이동 <br />
<code class="language-plaintext highlighter-rouge">gg</code> : 첫번째 줄로 이동 <br />
<code class="language-plaintext highlighter-rouge">[n]G</code> : n번째 줄로 이동  <br />
<code class="language-plaintext highlighter-rouge">$</code> : 커서가 위치한 줄의 맨 끝으로 이동   <br />
<code class="language-plaintext highlighter-rouge">O</code> : 커서가 위치한 줄의 맨 앞으로 이동   <br />
<code class="language-plaintext highlighter-rouge">w</code> : 커서가 한 단어씩 오른쪽으로 이동  <br />
<code class="language-plaintext highlighter-rouge">b</code> : 커서가 한 단어씩 왼쪽으로 이동</p>

<p>(2) 삭제
<code class="language-plaintext highlighter-rouge">x</code> : 한 문자 삭제,또는 Edit모드에서 백스페이스나 Delete키로 삭제 <br />
<code class="language-plaintext highlighter-rouge">dd</code> : 커서가 위치한 한 줄을 삭제 <br />
<code class="language-plaintext highlighter-rouge">d[커서이동]</code> : 커서가 이동하는 만큼 삭제</p>

<p>(3) : 수정
<code class="language-plaintext highlighter-rouge">r</code> : 커서가 위치한 부분의 문자 하나를 입력하는 문자로 대체 <br />
<code class="language-plaintext highlighter-rouge">u</code> : Ctrl + z 처럼 작업 취소</p>

<p>(4) : 복사 및 붙여넣기  <br />
<code class="language-plaintext highlighter-rouge">yy</code> : 커서가 위치한 한 줄을 복사 <br />
<code class="language-plaintext highlighter-rouge">y[커서이동]</code> : 커서 이동하는 만큼 복사</p>

<p><code class="language-plaintext highlighter-rouge">p</code> : 커서 밑이나 커서 다음에 붙여넣기</p>

<h3 id="edit-모드">Edit 모드</h3>
<ul>
  <li>실질적으로 문서를 편집하는 모드, 내용을 입력, 내용을 수정, 내용을 삭제  <br />
입력하고 싶은 내용을 입력하거나 백스페이스로 삭제</li>
</ul>

<h3 id="last-line-모드">Last Line 모드</h3>
<ul>
  <li>파일을 저장하거나, 종료하거나 저장하지 않고 그냥 종료, 검색,바꾸기 등</li>
</ul>

<p>(1) : 편집기 상태 변경  <br />
<code class="language-plaintext highlighter-rouge">:set nu</code> : 라인 넘버 표시  <br />
<code class="language-plaintext highlighter-rouge">:set nonu</code> : 라인 넘버 표시 안함   <br />
<code class="language-plaintext highlighter-rouge">:set ic</code> : 검색할 때 대소문자 무시   <br />
<code class="language-plaintext highlighter-rouge">:set noic</code> : 검색할 때 대소문자 구분</p>

<p>(2) : 검색 및 변환  <br />
<code class="language-plaintext highlighter-rouge">/[내용]</code> : 검색,<code class="language-plaintext highlighter-rouge">n</code> 다음검색,<code class="language-plaintext highlighter-rouge">N</code> 이전검색  <br />
<code class="language-plaintext highlighter-rouge">:%s/[찾을 내용]/[바꿀 내용]/g</code></p>

<p>(3) : 저장 및 종료  <br />
<code class="language-plaintext highlighter-rouge">:w</code> : 저장
<code class="language-plaintext highlighter-rouge">:q</code> : 종료 <br />
<code class="language-plaintext highlighter-rouge">:wq</code> : 저장 및 종료  <br />
<code class="language-plaintext highlighter-rouge">:w!</code> : 강제로 저장   <br />
<code class="language-plaintext highlighter-rouge">:q!</code> : 강제로 종료   <br />
<code class="language-plaintext highlighter-rouge">:wq!</code> : 저장 및 강제 종료</p>]]></content><author><name>Ino</name></author><category term="System" /><category term="vi" /><category term="vim" /><summary type="html"><![CDATA[vi 편집기 vi 편집기는 일반적으로 모드가 나누어져 있기 때문에, 따로 공부를 하지 않으면 사용할 때 어려움이 있다.]]></summary></entry><entry><title type="html">리눅스 기본구조와 명령어</title><link href="http://localhost:4000/system/2022/06/07/%EB%A6%AC%EB%88%85%EC%8A%A4-%EA%B8%B0%EB%B3%B8%ED%99%98%EA%B2%BD.html" rel="alternate" type="text/html" title="리눅스 기본구조와 명령어" /><published>2022-06-07T00:00:00+09:00</published><updated>2022-06-07T00:00:00+09:00</updated><id>http://localhost:4000/system/2022/06/07/%08%EB%A6%AC%EB%88%85%EC%8A%A4%20%EA%B8%B0%EB%B3%B8%ED%99%98%EA%B2%BD</id><content type="html" xml:base="http://localhost:4000/system/2022/06/07/%EB%A6%AC%EB%88%85%EC%8A%A4-%EA%B8%B0%EB%B3%B8%ED%99%98%EA%B2%BD.html"><![CDATA[<h2 id="리눅스-기본-환경">리눅스 기본 환경</h2>
<blockquote>
  <p>명령줄 인터페이스</p>
</blockquote>

<ul>
  <li>
    <p>텍스트 터미널을 통해 사용자의 컴퓨터가 상호 작용하는 방식을 뜻한다.</p>
  </li>
  <li>
    <p>즉, 작업 명령은 사용자가 컴퓨터 키보드 등을 통해 문자열의 형태로 입력하며 컴퓨터로부터의 출력 역시 문자열의 형태로 주어진다.</p>
  </li>
  <li>
    <p>명령어 구조 <br />
<code class="language-plaintext highlighter-rouge">명령어</code> : 시스템에서 특정 작업을 하기 위해 실행파일, 프로그램  <br />
<code class="language-plaintext highlighter-rouge">옵션</code> : 명령어를 어떻게 실행할 것인지 지정
일반적으로 대시(-) 문자 뒤에 옵션을 지정  <br />
<code class="language-plaintext highlighter-rouge">아규먼트(Argument)</code> :명령어에 의해서 영향을 받는 파일 or 디렉토리 등 특정 대상 <br />
ex) ls -al, ifconfig -a, netstat -anp</p>
  </li>
</ul>

<h2 id="디렉토리-관련-명령어">디렉토리 관련 명령어</h2>
<h3 id="먼저-디렉토리는-그냥-폴더이다">먼저 디렉토리는 그냥 폴더이다.</h3>
<ul>
  <li>pwd : 현재 작업 디렉토리 확인</li>
  <li>cd : 작업 디렉토리 변경 (change directory)</li>
  <li>ls : 디렉토리 내용 확인</li>
  <li>mkdir : 디렉토리 생성 (make directory)</li>
  <li>rmdir : 디렉토리 제거 (remove directory)</li>
  <li>mv : 디렉토리 이름 변경</li>
  <li>mv : 디렉토리 이동</li>
  <li>cp : 디렉토리 복사</li>
</ul>

<blockquote>
  <p>mv는 옵션에 따라 기능이 달라진다.</p>
</blockquote>

<ul>
  <li>ls [확인 할 디렉토리] : 디렉토리 내용 확인</li>
  <li>일반적으로 ls 명령어는 -al 옵션과 같이 사용한다</li>
  <li>
    <p>-a는 숨겨진 파일까지 모두 표시, -l은 좀 더 자세한 결과를 출력한다.</p>
  </li>
  <li>
    <p>mkdir [생성할 디렉토리 이름] : 지정한 이름으로 된 디렉토리를 생성 <br />
하위 구조도 함께 만들려면 -p옵션을 함께 사용</p>
  </li>
  <li>
    <p>rmdir [삭제할 디렉토리 이름] : 디렉토리를 삭제할 때 사용하는 명령어 내부에 특정 파일이나 디렉토리가 있으면 안에 파일을 삭제하고 삭제</p>
  </li>
  <li>
    <p>rm -r [삭제할 디렉토리 이름] : 파일을 삭제하는 rm명령어에 -r 옵션을 이용하여 디렉토리를 삭제할 수 있다.</p>
  </li>
  <li>cd [이동할 경로] : 작업 디렉토리를 다른 곳으로 변경할 때 사용</li>
</ul>

<h2 id="절대-경로--상대-경로">절대 경로 &amp; 상대 경로</h2>
<ul>
  <li>명령어를 사용할 때 경로를 입력하는 방식은 2가지가 있다.</li>
  <li>절대 경로 : 최상위 디렉토리인 /에서부터 특정 파일 또는 디렉토리의 경로를 모두 입력</li>
  <li>상대 경로 : 현재 작업 디렉토리를 기준으로 특정 파일 또는 디렉토리의 경로를 입력 <code class="language-plaintext highlighter-rouge">.</code>은 현재 디렉토리를 의미하고 <code class="language-plaintext highlighter-rouge">..</code>은 상위 디렉토리를 의미한다.
    <blockquote>
      <p>그래서 <code class="language-plaintext highlighter-rouge">cd ..</code> 이라는 명령어는 상위 폴더로 디렉토리를 이동해달라는 의미가 되는 것이다.  <br />
<code class="language-plaintext highlighter-rouge">cd /</code> 은 최상위 디렉토리로 이동해달라는건데, 그냥 <code class="language-plaintext highlighter-rouge">/</code>로 시작하면 절대경로가 되는데, 절대경로상 <code class="language-plaintext highlighter-rouge">/</code>는 가장 최상위 디렉토리라 그런것이다.</p>
    </blockquote>
  </li>
</ul>

<h2 id="파일-관련-명령어">파일 관련 명령어</h2>
<ul>
  <li>touch : 내용에 아무것도 없는 빈 파일을 생성</li>
  <li>
    <p>rm : 파일을 제거하는 명령어</p>
  </li>
  <li>
    <p>mv : 파일 이름 변경</p>
  </li>
  <li>
    <p>cp : 파일 복사</p>
  </li>
  <li>cat,head,tail,more  : 파일 내용 확인
    <blockquote>
      <p>전체적으로 디렉토리 명령어랑 겹치는 내용이 많다.</p>
    </blockquote>
  </li>
  <li>
    <p>touch [생성할 파일이름] : 생성할 파일이름 으로 비어있는 파일이 생성된다.</p>
  </li>
  <li>
    <p>rm, mv, cp 는 디렉토리 명령어랑 동일하게 사용한다.</p>
  </li>
  <li>
    <p>head는 옵션을 넣으면 위에서부터, tail은 아래서부터 보고 싶은 라인 수만큼 보여준다.</p>
  </li>
  <li>more 은 파일의 내용을 화면에 맞춰서 확인, space는 한 페이지씩 확인, enter는 한 줄 더 확인</li>
</ul>]]></content><author><name>Ino</name></author><category term="System" /><category term="linux" /><summary type="html"><![CDATA[리눅스 기본 환경 명령줄 인터페이스]]></summary></entry><entry><title type="html">깃과 깃허브</title><link href="http://localhost:4000/git/2022/05/31/Git%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C.html" rel="alternate" type="text/html" title="깃과 깃허브" /><published>2022-05-31T00:00:00+09:00</published><updated>2022-05-31T00:00:00+09:00</updated><id>http://localhost:4000/git/2022/05/31/Git%EC%97%90%20%EB%8C%80%ED%95%B4%EC%84%9C</id><content type="html" xml:base="http://localhost:4000/git/2022/05/31/Git%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C.html"><![CDATA[<h2 id="깃--버전관리시스템">깃 : 버전관리시스템</h2>
<blockquote>
  <p>VCS: version control system</p>
</blockquote>

<h2 id="깃허브">깃허브</h2>
<ul>
  <li>버전관리 깃의 원격 저장소 웹 호스팅 서비스</li>
  <li>소프트웨어 개발 활용 소셜 코딩 플랫폼</li>
  <li>전 세계 개발자를 위한 프로젝트 수행 협업 서비스</li>
  <li>프로젝트 개발 및 운영 서비스</li>
</ul>

<h2 id="깃허브를-쓰는-이유">깃허브를 쓰는 이유</h2>
<ul>
  <li>규모에 상관없이 모든 회사와 조직에서 원하는 공개 및 비공개 프로젝트에 필요한 중요 DevOps 기능을 제공하기 때문</li>
  <li>계획 수립 기능, 버그 수정, 변경 사항 관련 협업 등을 진행할 때 GitHub를 사용하면 전 세계 소프트웨어 개발자와 함께 작업 가능</li>
  <li>그리고 더 나은 제품을 만들 가능성 향상</li>
</ul>

<ol>
  <li>
    <p>Git은 프로젝트의 시간과 차원을 자유롭게 넘나들수 있도록 해준다.</p>
  </li>
  <li>
    <p>Git은 여러 사람들이 프로젝트에서 협업할 수 있도록 도와준다.</p>
  </li>
</ol>

<h2 id="깃허브의-주요기능">깃허브의 주요기능</h2>
<ul>
  <li>분기(branch)</li>
  <li>등록(Push)</li>
  <li>내려받기(Pull)</li>
</ul>

<h2 id="git-설치">git 설치</h2>
<blockquote>
  <p>mac기준으로 설명하겠다.</p>
</blockquote>

<ul>
  <li>
    <p>맥은 기본적으로 git이 설치되어 있다. 터미널에서 버전 확인 
<code class="language-plaintext highlighter-rouge">$git --version</code></p>
  </li>
  <li>
    <p>https://git-scm.com/ 에서 최신 버전 확인</p>
  </li>
</ul>

<h4 id="homebrew-설치">Homebrew 설치</h4>
<p>&lt; https://brew.sh/ &gt;</p>

<blockquote>
  <p>M1 또는 M2칩과 같은 SoC맥의 경우 Homebrew 가 동작하지 않는다면 아래르 추가로 실행해야 한다.</p>
  <blockquote>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">whomai</code> 명렁어로 <code class="language-plaintext highlighter-rouge">사용자명</code> 확인</li>
    </ul>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">echo 'eval "$(/opt/homebrew/bin/brew shellenv)"' &gt;&gt; /Users/사용자명/.zprofile</code></li>
      <li><code class="language-plaintext highlighter-rouge">eval "$(/opt/homebrew/bin/brew shellenv)"</code></li>
    </ul>
  </blockquote>
</blockquote>

<ul>
  <li>아래 명령어로 Git설치</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">$ brew install git</code></p>
<blockquote>
  <ul>
    <li>터미널 재실행 후 <code class="language-plaintext highlighter-rouge">git --version </code>으로 확인</li>
  </ul>
</blockquote>

<h2 id="git-최초-설정">Git 최초 설정</h2>
<p>Git 전역으로 사용자 이름과 이메일 주소를 설정</p>
<blockquote>
  <p>github 계정과는 상관없음</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">$git config --global user.name "(본인 이름)"</code><br />
<code class="language-plaintext highlighter-rouge">$git config --global user.email "(본인 이메일)"</code></p>

<p>아래 명령어들로 전역설정이 잘 되었는지 확인 <br />
<code class="language-plaintext highlighter-rouge">$git config --global user.name</code><br />
<code class="language-plaintext highlighter-rouge">$git config --global user.email</code></p>

<p>기본 브랜치명 변경<br />
기존 : <code class="language-plaintext highlighter-rouge">master</code> <br />
변경후 : <code class="language-plaintext highlighter-rouge">main</code>     <br />
<code class="language-plaintext highlighter-rouge">$ git config --global init.defaultBranch main</code></p>

<h2 id="프로젝트-생성--git-관리-시작">프로젝트 생성 &amp; Git 관리 시작</h2>

<p>vscode 내에서 git을 사용할 폴더 내부에서</p>
<blockquote>
  <p>현재 어느 폴더에 있는지 모르겠으면 터미널창에 <code class="language-plaintext highlighter-rouge">$ pwd</code> 로 원하는 폴더가 잘 선택되어있는지 확인한다</p>
</blockquote>

<p>폴더에 숨김모드로 .git 폴더가 생성되었는 지 확인한다.</p>
<ul>
  <li>이 폴더를 지우면 Git 관리 내역이 삭제된다.
    <blockquote>
      <p>맥에서 숨김파일 보기 : <code class="language-plaintext highlighter-rouge">command</code> + <code class="language-plaintext highlighter-rouge">shift</code> + <code class="language-plaintext highlighter-rouge">.</code></p>
    </blockquote>
  </li>
</ul>

<p>여기까지 잘 따라왔다면, 기본적인 Git 설정은 끝났다고 볼 수 있다.</p>]]></content><author><name>Ino</name></author><category term="git" /><category term="git" /><summary type="html"><![CDATA[깃 : 버전관리시스템 VCS: version control system]]></summary></entry><entry><title type="html">서버에 대해서</title><link href="http://localhost:4000/web/2022/05/30/Server%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C.html" rel="alternate" type="text/html" title="서버에 대해서" /><published>2022-05-30T00:00:00+09:00</published><updated>2022-05-30T00:00:00+09:00</updated><id>http://localhost:4000/web/2022/05/30/Server%EC%97%90%20%EB%8C%80%ED%95%B4%EC%84%9C</id><content type="html" xml:base="http://localhost:4000/web/2022/05/30/Server%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C.html"><![CDATA[<h2 id="1서버가-뭔데">1.서버가 뭔데?</h2>
<p>국밥집 이모다.<br />
우리가 순댓국집 가서 “이모~ 국밥하나 갖다주세요 “ 하면 이모가 국밥하나 갖다준다.<br />
서버도 똑같다.<br />
국밥집이모나 서버나 우리가 요청한걸 갖다주는 것 뿐이다. 
즉, 서버는 요청을 받으면 요청한 내용을 보내주는 프로그램인데,
HTTP요청에는 크게 4가지가 있는데, 읽기 쓰기 수정 삭제이다.</p>
<hr />

<h2 id="2읽기-get">2.읽기 (GET)</h2>
<p>특정 페이지를 get하면, 특정페이지를 서버에서 보내주는 형식이다.
우리가 네이버에서 네이버웹툰,네이버메일등에 들어가는 버튼을 누르면 지정사이트로 이동하는 것들이 모두 GET요청 하는 것이다.</p>

<h2 id="3쓰기-post">3.쓰기 (POST)</h2>
<p>댓글을 작성하거나, 글을 쓸 때 우리가 게시하는 것들을 받아들이는 것을 post요청이라고 한다.</p>

<h2 id="4수정-put">4.수정 (PUT)</h2>
<p>뭔가를 수정할 때</p>
<h2 id="5삭제-delete">5.삭제 (DELETE)</h2>
<p>뭔가를 삭제할 때</p>]]></content><author><name>Ino</name></author><category term="web" /><category term="web" /><category term="javascript" /><summary type="html"><![CDATA[1.서버가 뭔데? 국밥집 이모다. 우리가 순댓국집 가서 “이모~ 국밥하나 갖다주세요 “ 하면 이모가 국밥하나 갖다준다. 서버도 똑같다. 국밥집이모나 서버나 우리가 요청한걸 갖다주는 것 뿐이다. 즉, 서버는 요청을 받으면 요청한 내용을 보내주는 프로그램인데, HTTP요청에는 크게 4가지가 있는데, 읽기 쓰기 수정 삭제이다.]]></summary></entry><entry><title type="html">자바스크립트에 대해서</title><link href="http://localhost:4000/web/2022/05/29/Javascrpt%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C.html" rel="alternate" type="text/html" title="자바스크립트에 대해서" /><published>2022-05-29T00:00:00+09:00</published><updated>2022-05-29T00:00:00+09:00</updated><id>http://localhost:4000/web/2022/05/29/Javascrpt%EC%97%90%20%EB%8C%80%ED%95%B4%EC%84%9C</id><content type="html" xml:base="http://localhost:4000/web/2022/05/29/Javascrpt%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C.html"><![CDATA[<h2 id="1자바스크립트의-특징">1.자바스크립트의 특징</h2>
<p>자바스크립트는 HTML, CSS와 함께 웹을 구성하는 요소 중 하나로 웹 브라우저에서 동작하는 유일한 프로그래밍 언어이다.
(Vue,React,Angular 등도 javascript기반으로 만들어진 프레임워크이다.)</p>
<blockquote>
  <p>~python기반의 pyscript도 javascript 기반이다.~
자바스크립트는 기존의 프로그래밍 언어에서 많은 영향을 받았다.
기본 문법은 C, Java와 유사하고 Self에서는 프로토타입 기반 상속을, Scheme에서는 일급 함수의 개념을 차용했다.
~ 그래서 매우 근본이 없다.. 필요해서 막 만들었다는게 학계의 정설이다 ~  <br />
자바스크립트는 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어(Interpreter language)이다.</p>
</blockquote>

<blockquote>
  <p>그리고 여러 논란이 있지만(?) 자바스크립트는 프토로타입 기반의 객체지향 언어이다.</p>
</blockquote>

<h2 id="2자바스크립트의-실행환경">2.자바스크립트의 실행환경</h2>
<p>모든 브라우저는 자바스크립트를 해석하고 실행할 수 있는 자바스크립트 엔진을 내장하고 있다. 브라우저뿐만 아니라 Node.js도 자바스크립트 엔진을 내장하고 있다. 따라서 자바스크립트는 브라우저와 Node.js 환경에서 실행할 수 있다. 기본적으로 브라우저에서 동작하는 코드는 Node.js 환경에서도 동작한다.</p>

<p>그런데 브라우저와 Node.js는 존재 목적이 다르다. 브라우저는 HTML, CSS, 자바스크립트를 실행하여 웹 페이지를 화면에 렌더링하는 것이 주된 목적이지만, Node.js는 서버 개발 환경을 제공하는 것이 주된 목적이다.</p>

<p>예를 들어 브라우저는 HTML 요소를 선택하거나 조작하는 기능들의 집합인 DOM API를 기본적으로 제공한다. 하지만 서버 개발 환경을 제공하는 것이 주 목적인 Node.js는 클라이언트 사이드 Web API인 DOM API를 제공하지 않는다. 서버에서는 HTML 요소를 다룰 일이 없기 때문이다. 반대로 Node.js에서는 파일을 생성하고 수정할 수 있는 File 시스템을 기본 제공하지만 브라우저는 이를 지원하지 않는다.</p>]]></content><author><name>Ino</name></author><category term="web" /><category term="web" /><category term="javascript" /><summary type="html"><![CDATA[1.자바스크립트의 특징 자바스크립트는 HTML, CSS와 함께 웹을 구성하는 요소 중 하나로 웹 브라우저에서 동작하는 유일한 프로그래밍 언어이다. (Vue,React,Angular 등도 javascript기반으로 만들어진 프레임워크이다.) ~python기반의 pyscript도 javascript 기반이다.~ 자바스크립트는 기존의 프로그래밍 언어에서 많은 영향을 받았다. 기본 문법은 C, Java와 유사하고 Self에서는 프로토타입 기반 상속을, Scheme에서는 일급 함수의 개념을 차용했다. ~ 그래서 매우 근본이 없다.. 필요해서 막 만들었다는게 학계의 정설이다 ~ 자바스크립트는 개발자가 별도의 컴파일 작업을 수행하지 않는 인터프리터 언어(Interpreter language)이다.]]></summary></entry><entry><title type="html">프로그래밍이란?</title><link href="http://localhost:4000/web/2022/05/28/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C.html" rel="alternate" type="text/html" title="프로그래밍이란?" /><published>2022-05-28T00:00:00+09:00</published><updated>2022-05-28T00:00:00+09:00</updated><id>http://localhost:4000/web/2022/05/28/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%97%90%20%EB%8C%80%ED%95%B4%EC%84%9C</id><content type="html" xml:base="http://localhost:4000/web/2022/05/28/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C.html"><![CDATA[<h2 id="1본격적으로-js자바스크립트를-설명하기전에-프로그래밍이란-">1.본격적으로 JS(자바스크립트)를 설명하기전에, 프로그래밍이란 ?</h2>
<blockquote>
  <p>앞서 설명했던 html과 css와는 다르게 JS(자바스크린트를 편의상 JS라고 하겠다.) 는 프로그래밍언어이기 때문에 프로그래밍에 대해서 간략하게 설명하고 넘어가겠다.</p>
</blockquote>

<p><code class="language-plaintext highlighter-rouge">프로그래밍</code> 이란 컴퓨터에게 실행을 요구하는 일종의 커뮤니케이션이다. <br />
이를 위해서 무엇을 원하고 어떤식으로 컴퓨터에게 명령을 전달하는 지를 알아야한다.  <br />
다시 말해, 프로그래밍에 앞서 문제(요구사항)를 명확히 이해한 후 적절한 문제 해결 방안의 정의가 필요하다.
컴퓨터는 0과 1밖에 알지못하기 때문에 우리가 원하는 요구사항을 컴퓨터가 알아들을 수 있게 정확하고 상세하게 코드로 풀어서 쓰는 것을  <code class="language-plaintext highlighter-rouge">프로그래밍</code> 이라고한다. <br />
우리는 문제해결을 위해서 컴퓨터를 이용하기때문에 문제 해결 방안을 고려할때 컴퓨터의 입장에서 문제를 바라봐야 하는데 이때 필요한것이 컴퓨터적사고 (Computational thinking)이다.</p>

<hr />
<h2 id="2프로그래밍언어">2.프로그래밍언어</h2>
<p>컴퓨터는 인간이 이해할 수 있는 언어(자연어)가 아니라 기계가 이해할 수 있는 언어(기계어)로 명령을 전달해야 하는데, 
직접 기계어로 전달하는 것을 대신할 가장 유용한 대안은 인간이 이해할 수 있는 약속된 구문(Syntax)으로 구성된 <code class="language-plaintext highlighter-rouge">프로그래밍 언어(Programming Language)</code>를 사용하여 프로그램을 작성한 후, 그것을 컴퓨터가 이해할 수 있는 기계어로 변환하여 주는 일종의 번역기를 이용하는 것이다. 이 일종의 번역기를 <code class="language-plaintext highlighter-rouge">컴파일러(compiler)</code> 혹은 <code class="language-plaintext highlighter-rouge">인터프리터(interpreter)</code>라고 한다.
프로그래밍 학습은 일반적으로 프로그래밍 언어의 문법을 배우는 것부터 시작한다. 
이는 외국어 학습과 유사하다고 할 수 있다. 
외국어를 잘하려면 외국어 화자의 말이나 문장을 정확히 이해한 후, 문맥에 따른 적절한 어휘 선택, 그리고 순차적으로 결론을 향해 나아가는 문장 구성이 필요하다. 즉, 문법에 맞는 문장을 구성하는 것은 물론 의미(Semantics)를 가지고 있어야 언어의 역할을 충실히 수행할 수 있다.</p>
<hr />

<h2 id="3기본-개념과-동작-원리-이해의-중요성">3.기본 개념과 동작 원리 이해의 중요성</h2>
<p>프로그래머가 해야 할 일은 문제를 해결하기 위한 방안을 고안하고 이것을 문법에 맞게 코드로 구현하는 것이다. <br />
구현된 코드는 의도한 대로 정확히 동작하여 문제를 해결해야 한다.
이때 자신이 구현한 코드가 컴퓨터 내부에서 어떻게 동작할 것인지 그리고 무엇을 돌려 줄 것인지 예측 가능해야 한다. 
이를 위해서는 프로그래밍 언어의 기본 개념과 동작 원리를 정확히 이해하는 것이 중요하다.<br />
기본 개념과 동작 원리를 이해하지 못한 상태에서 Copy &amp; Paste로 단순히 동작만 하는 코드를 만들고 그것에 만족한다면 여러분이 구현한 코드는 신뢰할 수 없고 유지하고 보수하기 까다로운 코드가 될 것이다.
그리고 문제 해결 능력은 어느 선에서 성장을 멈추고 말 것이다.  <br />
동작 원리의 이해는 코드의 동작을 예측할 수 있게 돕는다.
또한 에러를 발생시키는 코드를 만나면 에러가 발생하는 원인을 이해해야 디버깅이 가능하다.
이를 위해 코드의 동작을 예측할 수 있는 능력은 필수 불가결적 요소이다.</p>]]></content><author><name>Ino</name></author><category term="web" /><category term="web" /><category term="javascript" /><summary type="html"><![CDATA[1.본격적으로 JS(자바스크립트)를 설명하기전에, 프로그래밍이란 ? 앞서 설명했던 html과 css와는 다르게 JS(자바스크린트를 편의상 JS라고 하겠다.) 는 프로그래밍언어이기 때문에 프로그래밍에 대해서 간략하게 설명하고 넘어가겠다.]]></summary></entry><entry><title type="html">시맨틱 웹(Semantic Web)</title><link href="http://localhost:4000/web/2022/05/26/%EC%8B%9C%EB%A7%A8%ED%8B%B1%EC%9A%94%EC%86%8C%EC%99%80-%EC%9B%B9.html" rel="alternate" type="text/html" title="시맨틱 웹(Semantic Web)" /><published>2022-05-26T00:00:00+09:00</published><updated>2022-05-26T00:00:00+09:00</updated><id>http://localhost:4000/web/2022/05/26/%EC%8B%9C%EB%A7%A8%ED%8B%B1%EC%9A%94%EC%86%8C%EC%99%80%20%EC%9B%B9</id><content type="html" xml:base="http://localhost:4000/web/2022/05/26/%EC%8B%9C%EB%A7%A8%ED%8B%B1%EC%9A%94%EC%86%8C%EC%99%80-%EC%9B%B9.html"><![CDATA[<h2 id="시맨틱-웹이-뭔데">시맨틱 웹이 뭔데?</h2>
<blockquote>
  <p><em>시멘틱 웹에 관한부분은 PoiemaWeb (웹프로그래밍튜토리얼) 사이트 참조</em></p>
</blockquote>

<p>2022년 퍼블리싱 되고 있는 웹사이트의 갯수는 약20억개, 인터넷사용자수는 53만명이다.</p>
<blockquote>
  <p><em>출처 : https://www.internetlivestats.com/</em></p>
</blockquote>

<p>대부분의 인터넷 사용자는 원하는 정보를 취득하기 위해 Google이나 Naver와 같은 검색사이트를 이용한다. <br />
웹사이트는 검색엔진에 의한 노출이 매우 중요하다. <br />
당연한 것이 검색엔진에 노출되지 않는 웹사이트에는 접속하는 이도 없기 때문이다. <br />
검색엔진은 이 시대의 가장 강력한 권력 중의 하나라고 말할 수도 있겠다.</p>

<p>SEO(검색엔진 최적화: Search Engine Optimization)같은 마케팅 도구를 사용하여 검색엔진이 본인의 웹사이트를 검색하기 알맞은 구조로 웹사이트를 조정하기도 하는데, 이것은 기본적으로 검색엔진이 웹사이트 정보를 어떻게 수집하는지 아는 것으로 부터 시작된다.</p>

<p>검색엔진은 로봇(Robot)이라는 프로그램을 이용해 매일 전세계의 웹사이트 정보를 수집한다.(이것을 크롤링이라 하며 검색엔진의 크롤러가 이를 수행한다.) <br />
그리고 검색 사이트 이용자가 검색할 만한 키워드를 미리 예상하여 검색 키워드에 대응하는 인덱스(색인)을 만들어 둔다.(이것을 인덱싱이라 하며 검색엔진의 인덱서가 이를 수행한다.)</p>

<hr />

<p>인덱스를 생성할 때 사용되는 정보는 검색 로봇이 수집한 정보인데 결국 웹사이트의 HTML 코드이다. <br />
즉, 검색 엔진은 HTML 코드 만으로 그 의미를 인지하여야 하는데 이때 시맨틱 요소(Semantic element)를 해석하게 된다.</p>
<blockquote>
  <p><em>여담으로, python에서 Beautiful Soup 라이브러리를 이용하면 직접 웹크롤링/스크래핑을 할 수 있다.</em></p>
</blockquote>

<p>HTML으로 작성된 문서는 컴퓨터가 해석할 수 있는 메타데이터와 사람이 사용하는 자연어 문장이 뒤섞여 있다. <br />
아래 코드를 보면 1행과 2행은 브라우저에서 동일한 외형을 갖는다. 이는 h1 태그의 디폴트 스타일이 1행과 같기 때문이다.</p>
<blockquote>
  <p>b태그는 bold의 약자로 boid체(두꺼운글씨체)이다.</p>
</blockquote>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;font</span> <span class="na">size=</span><span class="s">"6"</span><span class="nt">&gt;&lt;b&gt;</span>Hello<span class="nt">&lt;/b&gt;&lt;/font&gt;</span>
<span class="nt">&lt;h1&gt;</span>Hello<span class="nt">&lt;/h1&gt;</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/95608811/169962379-1c21cd6f-9b7f-4eee-a887-a5c82a6455ba.png" width="600px" /></p>

<p>그러나 1행의 요소는 의미론적으로 어떤 의미도 가지고 있지 않다.<br />
즉, 의도가 명확하지 않다. 
개발자가 의도한 요소의 의미를 명확하게 나타내지 않고 다만 폰트 크기와 볼드체를 지정하는 메타데이터만을 브라우저에게 알리고 있다.<br />
그러나 2행의 요소는 header(제목) 중 가장 상위 레벨이라는 의미를 내포하고 있어서 개발자가 의도한 요소의 의미가 명확히 드러나고 있다. 
이것은 코드의 가독성을 높이고 유지보수를 쉽게한다.</p>

<p><strong>검색엔진은 대체로 h1 요소 내의 콘텐츠를 웹문서의 중요한 제목으로 인식하고 인덱스에 포함시킬 확률이 높다.또한 사람도 h1 요소 내의 콘텐츠가 제목임을 인식할 수 있다.</strong></p>

<p>시맨틱 요소로 구성되어 있는 웹페이지는 검색엔진에 보다 의미론적으로 문서 정보를 전달할 수 있고 검색엔진 또한 시맨틱 요소를 이용하여 보다 효과적인 크롤링과 인덱싱이 가능해졌다. 
즉, 시맨틱 태그란 브라우저, 검색엔진, 개발자 모두에게 콘텐츠의 의미를 명확히 설명하는 역할을 한다.<br />
시맨틱 태그에 의해 컴퓨터가 HTML 요소의 의미를 보다 명확히 해석하고 그 데이터를 활용할 수 있는 시맨틱 웹이 실현될 수 있다.</p>

<p>시맨틱 웹이란 웹에 존재하는 수많은 웹페이지들에 메타데이터(Metadata)를 부여하여,<br />
기존의 잡다한 데이터 집합이었던 웹페이지를 ‘의미’와 ‘관련성’을 가지는 거대한 데이터베이스로 구축하고자 하는 발상이다.</p>

<p>HTML 요소는 non-semantic 요소, semantic 요소로 구분할 수 있다.</p>

<blockquote>
  <p>non-semantic 요소</p>
</blockquote>

<p>div, span 등이 있으며 이들 태그는 content에 대하여 어떤 설명도 하지 않는다.</p>

<blockquote>
  <p>semantic 요소</p>
</blockquote>

<p>form, table, img 등이 있으며 이들 태그는 content의 의미를 명확히 설명한다,</p>

<p>간략히하자면, 웹페이지가 검색노출이 잘되게끔 하고싶다면,단순히 디자인적인 부분만을 고려하여 태그를 사용하는게 아닌 중요한 내용과 그렇지 않은 내용들을 semantic 요소를 고려하여 태그를 작성하면 된다 !</p>]]></content><author><name>Ino</name></author><category term="web" /><category term="web" /><category term="html" /><summary type="html"><![CDATA[시맨틱 웹이 뭔데? 시멘틱 웹에 관한부분은 PoiemaWeb (웹프로그래밍튜토리얼) 사이트 참조]]></summary></entry></feed>